:PROPERTIES:
:ID:       ac338634-949e-4e3a-8d75-45bed92243c6
:END:
#+title: Setting up and using 
#+title: Xilinx KRIA KV260
#+filetags: :export:
#+subtitle: \begin{CJK}{UTF8}{min}南山大学\end{CJK}
#+author: Vincent Conus
#+email: vincent.conus@protonmail.com
#+date: 2023-8-30

* Headers and LaTeX settings for export                               :noexport:
A large amount of headers and parameters are needed in order
to have this "README" document being exportable as a LaTeX
document formatted the way I wanted it to be.

The detail can be seen in the raw ~.org~ version of this README
and stays hidden in a :noexport: section in this report.

#+DESCRIPTION: A report presenting how to use and set Xilinx's Kria board
#+LANGUAGE: English

#+OPTIONS: H:3 toc:t date:t title:t email:t

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:[10pt]
#+LATEX_HEADER: \usepackage[a4paper, total={6.5in, 9in}]{geometry}

#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{breaklines}
#+LATEX_HEADER: \usepackage[AUTO]{inputenc}
#+LATEX_HEADER: \renewcommand{\familydefault}{\sfdefault}
#+LATEX_HEADER: \usemintedstyle{vs}

#+LATEX_HEADER: \usepackage[most]{tcolorbox}

#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \usepackage{xurl}
#+LATEX_HEADER: \usepackage{fontawesome5}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{float}

#+LATEX_HEADER: \newcommand{\gitlab}[1]{%
#+LATEX_HEADER:    \href{#1}{GitLab \faGitlab}}

#+begin_src emacs-lisp :exports results :results none :eval export
  (make-variable-buffer-local 'org-latex-title-command)
  (setq org-latex-title-command (concat
     "\\begin{titlepage}\n"
     "\\centering\n"
     "{\\LARGE %t \\par }\n"
     "\\vspace{5mm}\n"
     "{\\large %s \\par}\n"
     "\\vspace{1cm}\n"
     "{\\large %D \\par}\n"
     "\\vspace{2cm}\n"
     "{\\large %a -  Source available at \\gitlab{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation} \\par}\n"
     "\\vspace{3cm}\n"
     "\\includegraphics[width=0.8\\textwidth]{./img/board}"
     "\\end{titlepage}\n"))
#+end_src

#+begin_src emacs-lisp :exports results :results none :eval export
    (make-variable-buffer-local 'org-latex-toc-command)
    (setq org-latex-toc-command (concat
       "\\tableofcontents\n"
       "\\pagebreak\n"))
#+end_src

* Building this report from the LaTeX file                            :noexport:
The base file for this report is actually this README.org file itself.
However, upon local build, this file is regularly exported as
a ~.tex~ file that can be built normally.
On a moderately recent Ubuntu-base distribution, the following packages seemed to be required to build the
report:

#+BEGIN_SRC bash
  sudo apt-get install texlive-base texlive-latex-recommended texlive-lang-japanese
#+END_SRC

Then, the actual build can be made with a simple:

#+BEGIN_SRC bash
  pdflatex README.tex
#+END_SRC


* Introduction & motivation
This guide will present how to setup and use Xilinx's KRIA board, in particular
for running ROS on a host Ubuntu system, as well as for deploying
micro-ROS as a firmware on the MCU part of this board's chip.

The use of this device in particular is interesting because of the presence
of a CPU comprising both a general purpose ARM core, capable of running
a Linux distribution, as well as another ARM core, real-time enabled,
capable to run a RTOS. The figure [[fig:map]] below shows a schematic
view of the overall system we are trying to archive.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The Linux and ROS2 environment (orange) will
#+CAPTION: communicate with the real-time, FreeRTOS and micro-ROS
#+CAPTION: side (blue) using RPMsg (shared memory).
#+NAME: fig:map
[[file:./img/map.png]]


#+INCLUDE: "./boot_firmware.org" :minlevel 1
* COMMENT [[file:boot_firmware.org][Boot firmware]]

* Installing Linux
Withe the boot firmware being up-to-date, we can proceed to install a Linux distribution
on our Kria board. The step needed to archive a full installation of Ubuntu LTS 22.04
will be presented in this section[fn:7]. The figure [[fig:map_linux]] below shows
where this operating system sits in the general system we are implementing.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The Linux operating system (red border)runs on the
#+CAPTION: APU (application, general purpose) side of the Kria board CPU.
#+CAPTION: It is the base layer for the ROS2 system.
#+NAME: fig:map_linux
[[file:./img/map_linux.png]]

** Preparing and booting a Ubuntu 22.04 media
An [[https://ubuntu.com/download/amd-xilinx][official Ubuntu image]] exists and is
provided by Xilinx, allowing the OS installation to be quick and
straightforward.
Ubuntu is a common and easy to use distribution. Furthermore,
it allows to install ROS2 as a package, which is most convenient and will be
done later in this guide.

Once the image has been downloaded at [[https://ubuntu.com/download/amd-xilinx][Canonical's page]]
we can flash it onto the SD card, with the following instructions.

#+LATEX: \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
*DANGER*: The next part involve the ~dd~ command writing on disks!!!
As always with the dd command, thou have to be *VERY* careful on what arguments
thou give. Selecting the wrong disk will result on the destruction of
thy data !!
_If you are unsure of what to do, seek assistance !_
#+LATEX: \end{tcolorbox}

With the image available on thy machine and a SD card visible as ~/dev/sda~ device[fn:1]
one can simply run the ~dd~ command as follow to write the image to a previously formatted drive (here ~/dev/sda~):

#+BEGIN_SRC sh
  unxz iot-limerick-kria-classic-desktop-2204-x07-20230302-63.img.xz
  sudo dd if=iot-limerick-kria-classic-desktop-2204-x07-20230302-63.img \
       of=/dev/sda status=progress bs=8M && sync
#+END_SRC


Once the SD card is flashed and put back in the board, the micro-USB cable can be
connected from the PC to the board. It is then possible to
connect to the board in serial with an appropriate tool, for example ~picocom~,
as in the following example (the serial port that "appeared" was the ~/dev/ttyUSB1~ in this case,
and the 115200 bitrate is the default value for the board):

#+BEGIN_SRC sh
  sudo picocom /dev/ttyUSB1 -b 115200
#+END_SRC

Once logged in, it is typically easier and more convenient to connect the board
using SSH. When the board is connected to the network, it is possible to know
it's IP address with the ~ip~ command; then it is possible to connect to
the board with ssh, as follow (example, with the first command to be run on the board
and the second one on the host PC, both without the first placeholder hostnames):


#+BEGIN_SRC sh
  kria# ip addr

  host# ssh ubuntu@192.168.4.11
#+END_SRC

** Network and admin setups
This section presents a variety of extra convenience configurations
that can be used when setting-up the Kria board.

*** Proxy and DNS
An issue that can occur when connecting the board to the internet is the
conflicting situation with the university proxy.
Indeed, as the network at Nanzan University requires to go through a proxy,
some DNS errors appeared.

Firstly, it is possible to set a DNS IP address in ~/etc/resolv.conf~ by
editing it and adding your favorite DNS, for example ~nameserver 1.1.1.1~
next to the other ~nameserver~ entry. The resolver can then be restarted.

#+BEGIN_SRC sh
  sudo nano /etc/resolv.conf

  sudo systemctl restart systemd-resolved
#+END_SRC

Secondly, it might become needed to setup the proxy for the school.

This can be done as follow, by exporting a https base proxy configuration
containing you AXIA credentials (this is specific to Nanzan University IT system),
then by consolidating the configuration for other types of connections in the ~bashrc~:

#+BEGIN_SRC sh
  export https_proxy="http://<AXIA_username>:\
         <AXIA_psw>@proxy.ic.nanzan-u.ac.jp:8080"

  echo "export http_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export https_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export ftp_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export no_proxy=\"localhost, 127.0.0.1,::1\"" \
       >> ~/.bashrc
#+END_SRC

Eventually the board can be rebooted in order for the setup to get applied cleanly.

*** ~root~ password
#+LATEX: \begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
*WARNING*: Depending on your use-case, the setup presented in this
subsection can be a critical security breach as it remove the need for a root
password to access the admin functions of the board's Linux.
_When in doubt, do not apply this configuration!!_
#+LATEX: \end{tcolorbox}

If you board does not hold important data
and is available to you only, for test or development,
it might be convenient for the ~sudo~ tool to not ask for the
password all the time.
This change can be done by editing the sudoers file, and
adding the parameter ~NOPASSWD~
at the ~sudo~ line:

#+BEGIN_SRC sh
sudo visudo

%sudo   ALL=(ALL:ALL) NOPASSWD: ALL
#+END_SRC

Again, this is merely a convenience setup for devices staying at you desk. If
the board is meant to be used in any kind of production setup, a password
should be set for making administration tasks.

With all of these settings, you should be able to update the software of your
board without any issues:
#+BEGIN_SRC sh
sudo apt-get update
sudo apt-get dist-upgrade
sudo reboot now
#+END_SRC


*** Static IP address
A static IP can be set by writing the following
configuration into your ~netplan~ configuration file.

The name of the files might vary:
#+BEGIN_SRC sh
  sudo nano /etc/netplan/50-cloud-init.yaml
#+END_SRC

You can then set the wanted IP as follow. Note that a custom DNS was
also set in that case.
#+BEGIN_SRC yaml
  network:
    renderer: NetworkManager
    version: 2
    ethernets:
      eth0:
        addresses:
          - 192.168.11.103/24
        routes:
          - to: default
            via: 192.168.11.1
        nameservers:
          addresses:
            - 8.8.8.8
            - 1.1.1.1
#+END_SRC

Finally, the change in settings can be applied
as follow:

#+BEGIN_SRC sh
  sudo netplan apply
#+END_SRC

*** Purging ~snap~
As the desktop-specific software are not used at all in the case
of our project, there are some packages that can be purges in order for the
system to become more lightweight.

In particular, the main issue with Ubuntu systems is the forced integration of
Snap packages. Here are the command to use in order to remove all of that.
These steps take a lot of time and need to be executed in that specific order[fn:2],
but the system fan runs sensibly slower without all of this stuff:

#+BEGIN_SRC sh
  sudo systemctl disable snapd.service
  sudo systemctl disable snapd.socket
  sudo systemctl disable snapd.seeded.service

  sudo snap list #show installed package, remove then all:
  sudo snap remove --purge firefox
  sudo snap remove --purge gnome-3-38-2004
  sudo snap remove --purge gnome-42-2204
  sudo snap remove --purge gtk-common-themes
  sudo snap remove --purge snapd-desktop-integration
  sudo snap remove --purge snap-store
  sudo snap remove --purge bare
  sudo snap remove --purge core20
  sudo snap remove --purge core22
  sudo snap remove --purge snapd
  sudo snap list # check that everything is uninstalled

  sudo rm -rf /var/cache/snapd/
  sudo rm -rf ~/snap
  sudo apt autoremove --purge snapd

  systemctl list-units | grep snapd
#+END_SRC

*** Other unused heavy packages
Some other pieces of software can safely be removed since the desktop is
not to be used:

#+BEGIN_SRC sh
  sudo apt-get autoremove --purge yaru-theme-icon \
  fonts-noto-cjk yaru-theme-gtk vim-runtime \
  ubuntu-wallpapers-jammy humanity-icon-theme

  sudo apt-get autoclean
  sudo reboot now
#+END_SRC

* Enabling ~remoteproc~
One of the advantage of this Kria board, as cited previously, is the presence of
multiple types of core (APU, MCU, FPGA) on the same chip.

The part in focus in this guide is the usage of both the APU, running
a Linux distribution and ROS2; and the MCU, running FreeRTOS and micro-ROS.
Online available guides[fn:3] [fn:4] also provide information on how to deploy these types
of systems and enabling ~remoteproc~ for the Kria board, but this guide
will show a step-by-step, tried process to have a heterogeneous system
up and running.

The communication between both side is meant to be done using shared memory, but
some extra setup is required in order to be running the real-time firmware, in particular
for deploying micro-ROS on it.

As a first step in that direction, this section of the report
will present how to setup and use as an example firmware that utilizes the
~remoteproc~ device in Linux in order to access shared memory
and communicate with the real-time firmware using the RPMsg system.

** Device-Tree Overlay patching
The communication system and interaction from the Linux side towards the real-time capable core
is not enabled by default within the Ubuntu image provided by Xilinx.

In that regard, some modification of the device tree overlay (DTO) is required in order to have
the ~remoteproc~ system starting.

Firstly, we need to get the original firmware device tree, converted
into a readable format (DTS):

#+BEGIN_SRC sh
  sudo dtc /sys/firmware/fdt 2> /dev/null > system.dts
#+END_SRC

Then, a custom-made patch file can be downloaded and applied.
This file is available at the URL visible in the command below
but also in this report appendix [[DTO patch]].

#+BEGIN_SRC sh
  wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/\
       blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch

  patch system.dts < system.patch
#+END_SRC

As for the board to be able to reserve the correct amount of memory with the new settings, some
~cma~ kernel configuration is needed[fn:5]:

#+BEGIN_SRC sh
  sudo nano /etc/default/flash-kernel

  LINUX_KERNEL_CMDLINE="quiet splash cma=512M cpuidle.off=1"
  LINUX_KERNEL_CMDLINE_DEFAULTS=""
  sudo flash-kernel
#+END_SRC

Now the DTS file has been modified, one can regenerate the binary and place it on the ~/boot~ partition
and reboot the board:

#+BEGIN_SRC sh
  dtc -I dts -O dtb system.dts -o user-override.dtb
  sudo mv user-override.dtb /boot/firmware/
  sudo reboot now
#+END_SRC

After rebooting, you can check the content of the \verb|remoteproc| system directory,
and a ~remoteproc0~ device should be visible, as follow:

#+BEGIN_SRC sh
  ls /sys/class/remoteproc/
  #  remoteproc0
#+END_SRC

If it is the case, it means that the patch was successful and  that the remote processor is
ready to be used!
#+LATEX: \pagebreak

* Building an example RPMsg real-time firmware
As visible on the official [[https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1837006921/OpenAMP+Base+Hardware+Configurations\#Build-RPU-firmware][Xilinx documentation about building a demo firmware]],
this section will present the required steps for building a new firmware for the R5F
core of our Kria board.

The goal here is to have a demonstration firmware running,
able to use the RPMsg system to communicate with the Linux APU.
The figure [[fig:map_microros]] below shows where the real-time firmware
is positioned in the global project.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The FreeRTOS firmware and it's application (red border) are
#+CAPTION: running on the real-time capable side of the Kria CPU.
#+CAPTION: A micro-ROS application is shown here, but any real-time firmware will
#+CAPTION: be deployed in the same way.
#+NAME: fig:map_microros
[[file:./img/map_microros.png]]

** Setting up the IDE
Xilinx's Vitis IDE is the recommended tool used to build software for the Xilinx boards.
It also include the tools to interact with the FPGA part, making the whole
software very large (around 200GB of disk usage).

However, this large tool-set allows for a convenient development environment, in particular
in our case where some FreeRTOS system, with many dependencies is to be build.

The installer can be found on [[https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html][Xilinx download page]]. You will need to get
a file named something like ~Xilinx_Unified_2022.2_1014_8888_Lin64.bin~[fn:6].

Vitis IDE installer is compatible with versions of Ubuntu, among other distributions,
but not officially yet for the 22.04 version.
Furthermore, the current install was tested on Pop OS, a distribution derived from Ubuntu.
However, even with this more unstable status, no major problems were encountered
with this tool during the development stages.

This guide will present a setup procedure that supposedly works for all distributions based on the newest
LTS from Ubuntu. For other Linux distributions or operating system, please refer to the official documentation.

*** Dependencies & installation
Some packages are required to be installed on the host system
in order for the installation process to happen successfully:

#+BEGIN_SRC sh
  sudo apt-get -y update

  sudo apt-get -y install libncurses-dev \
       ncurses-term \
       ncurses-base \
       ncurses-bin \
       libncurses5 \
       libtinfo5 \
       libncurses5-dev \
       libncursesw5-dev
#+END_SRC

Once this is done, the previously downloaded binary installer can be executed:

#+BEGIN_SRC sh
  ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
#+END_SRC

If it is not possible to run the previous command, make the file executable with the ~chmod~ command:

#+BEGIN_SRC sh
  sudo chmod +x ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
#+END_SRC

From there you can follow the step-by-step graphical installer.
The directory chosen for the rest of this guide for the Xilinx directory
is directly the ~$HOME~, but the installation can be set elsewhere is needed.

#+LATEX: \begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
*WARNING*: This whole procedure can take up to multiple hours to complete
and is prone to failures (regarding missing dependencies, typically),
so your schedule should be arranged accordingly.
#+LATEX: \end{tcolorbox}

*** Platform configuration file generation
In order to have the libraries and configurations in the IDE ready to be used for our board,
we need to obtain some configuration files that are specific for the Kria KV260,
as presented in the [[https://xilinx.github.io/kria-apps-docs/kv260/2022.1/build/html/docs/build_vitis_platform.html?highlight=xsa][Xilinx guide for Kria and Vitis]].

A Xilinx [[https://github.com/Xilinx/kria-vitis-platforms][dedicated repository]] is available for us to download  such configurations,
but they required to be built.

As for the dependencies, ~Cmake~, ~tcl~ and ~idn~ will become needed in order to build the firmware.
Regarding ~idn~, some version issue can happen, but as discussed [[https://support.xilinx.com/s/question/0D52E00006jrzsYSAQ/platform-project-cannot-be-created-on-vitis?language=en\_US][in a thread on Xilinx's forum]],
if ~libidn11~ is specifically required but not available (it is the case for Ubuntu 22.04),
creating a symbolic link from the current, 12 version works as a workaround.

Here are the steps for installing the dependencies and building this configuration file:

#+BEGIN_SRC sh
  sudo apt-get update
  sudo apt-get install cmake tcl libidn11-dev \
  libidn-dev libidn12 idn
  sudo ln -s /usr/lib/x86_64-linux-gnu/libidn.so.12 \
  /usr/lib/x86_64-linux-gnu/libidn.so.11

  cd ~/Xilinx
  git clone --recursive \
  https://github.com/Xilinx/kria-vitis-platforms.git
  cd kria-vitis-platforms/k26/platforms
  export XILINX_VIVADO=/home/$USER/Xilinx/Vivado/2022.2/
  export XILINX_VITIS=/home/$USER/Xilinx/Vitis/2022.2/
  make platform PLATFORM=k26_base_starter_kit
#+END_SRC

** Setting up and building a new project for the Kria board
With the platform configuration files available, we can now use the IDE to generate a
new project for our board. The whole process will be described with screen captures and
captions.

#+ATTR_LATEX: :width .5\textwidth
#+CAPTION: We are starting with creating a "New Application Project"
#+CAPTION: You should be greeted with this wizard window. Next.
#+NAME: fig:project1
[[file:./img/vitis_new/project1.png]]

#+ATTR_LATEX: :width .5\textwidth
#+CAPTION: For the platform, we need to get our build Kria configuration.
#+CAPTION: In the "Create a new platform" tab,
#+CAPTION: click the "Browse..." button.
#+NAME: fig:project2
[[file:./img/vitis_new/project2.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In the file explorer, we should navigate in the "k26" directory,
#+CAPTION: where the configuration file was build.
#+CAPTION: From here we are looking for a ".xsa" file, located in a "hw" directory, as visible.
#+NAME: fig:project3
[[file:./img/vitis_new/project3.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: With the configuration file loaded, we can now select a name for our
#+CAPTION: platform, but most importantly, we have to select the "psu Cortex5 0" core as a target.
#+CAPTION: The other, Cortex 53 is the APU running Linux.
#+NAME: fig:project4
[[file:./img/vitis_new/project4.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In this next window, we can give a name to our firmware project.
#+CAPTION: It is also critical here to select the core we want to build for.
#+CAPTION: Once again, we want to use the "psu cortex5 0".
#+NAME: fig:project5
[[file:./img/vitis_new/project5.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: Here, we want to select "freertos10 xilinx" as our Operating System.
#+CAPTION: The rest can remain unchanged.
#+NAME: fig:project6
[[file:./img/vitis_new/project6.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: Finally, we can select the demonstration template we are going to use;
#+CAPTION: here we go with "OpenAMP echo-test" since we want to
#+CAPTION: have some simple try of the RPMsg system. Finish.
#+NAME: fig:project7
file:./img/vitis_new/project7.png

#+LATEX: \pagebreak
In the Xilinx documentation, it is made mention of the addresses setting that should be checked in the ~script.ld~ file.
The values in the figure [[fig:projectmem]] below look different from what could be set in the DTO for the Linux side, but they appear to
work for the example we are running, including the new DTO patch without overlapping memory:


#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: lscript.ld memory configuration for the firmware memory setup.
#+CAPTION: The same file is available as a whole in this repository's src directory.
#+NAME: fig:projectmem
file:./img/vitis_new/project_mem.png


Once your example project is built and you have a ~.elf~ file available, you can
jump directly to the [[Loading the firmware]] section to see how to deploy and use your firmware.

The section in between will present setup specifically needed for micro-ROS.

** Enabling the Stream Buffer system
This is a subpart in the general configuration in the project related to some specific
functions for FreeRTOS threads messaging system, however, this point in particular
created so much pain I needed to include in early in this guide for not to forget about it
and keeping a clear track on how to enable this setting.

Indeed, two settings need to be enabled in order to be able to call
functions such as ~xMessageBufferCreate~, useful when working with tasks
in FreeRTOS, as visible in the figure [[fig:streambuffer]] below:

#+ATTR_LATEX: :width .8\textwidth
#+CAPTION: Enabling Stream Buffer in the Vitis IDE setting: this is a setting that can
#+CAPTION: be found in the "platform.spr" element of your project (the platform, not the firmware
#+CAPTION: project itself). From that file, you can access the settings with the button "Modify BSP Settings",
#+CAPTION: and then as visible, in the tab ~freertos10_xilinx~, it is needed to toggle
#+CAPTION: here the ~stream_buffer~ setting
#+CAPTION: in the ~kernel_features~, from the default "false" to "true".
#+NAME: fig:streambuffer
[[file:./img/streambuffer.png]]

#+LATEX: \pagebreak
The second setting is useful in the case when a buffer callback function is used, such as\\
~xMessageBufferCreateWithCallback~.
In that case, you must include ~#define configUSE_SB_COMPLETED_CALLBACK 1~ on the top of you header
file (in our project, this will happen in the ~microros.h~ header file),
before the ~#include "FreeRTOS.h"~ in order to override the setting from this include.


#+LATEX: \pagebreak
* RPMsg ~echo_test~ software
In order to test the deployment of the firmware on the R5F side, and in particular
to test the RPMsg function, we need some program on the Linux side of the Kria
board to "talk" with the real-time side.

Some source is provided by Xilinx to build a demonstration software that does
this purpose: specifically interact with the demonstration firmware.

Here are the steps required to obtain the sources, and build the program.

As a reminder, this is meant to be done on the Linux running on the
Kria board, NOT on your host machine !

#+BEGIN_SRC sh
  git clone https://github.com/Xilinx/meta-openamp.git
  cd  meta-openamp
  git checkout xlnx-rel-v2022.2
  cd  ./recipes-openamp/rpmsg-examples/rpmsg-echo-test
  make
  sudo ln -s $(pwd)/echo_test /usr/bin/
#+END_SRC

Once this is done, it it possible to run the test program from the Kria board's Ubuntu
by running the ~echo_test~ command.

* Building micro-ROS as a static library
In this section, the goal is to build the micro-ROS library in order to be
able to integrate it's functions into our Cortex R5F firmware.

All of this should be done via cross-compiling on a host machine, however
it is most common in the guides about micro-ROS to build the firmwares and libraries within a Docker,
so we can have access of the ROS environment without installing it permanently.

One can simply run this command to summon a ROS2 Docker[fn:8] with the wanted version,
but first we also need to check the cross-compilation tools.

We are downloading the latest ~arm-none-eabi~ gcc compiler directly from the ARM website.

The cross-compilation tool can then be extracted, set as our ~toolchain~ variable,
then passed as a parameter when creating the Docker container:
#+BEGIN_SRC sh
  pushd /home/$USER/Downloads
  wget https://developer.arm.com/-/media/Files/downloads/\
  gnu/12.2.mpacbti-rel1/binrel/arm-gnu-toolchain-12.2\
  .mpacbti-rel1-x86_64-arm-none-eabi.tar.xz
  tar -xvf arm-gnu-toolchain-12.2.mpacbti-rel1-x86_64-\
  arm-none-eabi.tar.xz
  popd

  toolchain="/home/$USER/Downloads/arm-gnu-toolchain-\
  12.2.mpacbti-rel1-x86_64-arm-none-eabi/"


  docker run -d --name ros_build -it --net=host \
  --hostname ros_build \
  -v /dev:/dev \
  -v $toolchain:/armr5-toolchain \
  --privileged ros:iron
#+END_SRC

Now the container named ~ros_build~ was created, it is possible to "enter" it, and having access
to the tools in it by running the following command that will open a ~bash~ shell in said container:
#+BEGIN_SRC sh
  docker exec -it ros_build bash
#+END_SRC

Now we are in the ROS2 container, we can build the micro-ROS firmware as presented
in the [[https://micro.ros.org/docs/tutorials/advanced/create\_custom\_static\_library][dedicated micro-ROS guide]]:
#+BEGIN_SRC sh
  sudo apt update 
  sudo apt-get -y install python3-pip \
       wget \
       nano

  . /opt/ros/\$ROS_DISTRO/setup.bash

  mkdir microros_ws
  cd microros_ws
  git clone -b \$ROS_DISTRO \
      https://github.com/micro-ROS/micro_ros_setup.git \
      src/micro_ros_setup

  sudo rosdep fix-permissions &&\
      rosdep update &&\
      rosdep install --from-paths src --ignore-src -y

  colcon build
  . ./install/local_setup.bash

  ros2 run micro_ros_setup create_firmware_ws.sh generate_lib
#+END_SRC

From that point, we will need some extra configuration files for our Cortex R5F.

Both configuration files[fn:9] will be downloaded from my repository;
we also are going to copy the cross-compiler into the microros workspace,
then we can build the library with the following ros2 command:
#+BEGIN_SRC sh
  wget https://gitlab.com/sunoc/xilinx-kria-kv260-\
  documentation/-/raw/main/src/custom_r5f_toolchain.cmake

  wget https://gitlab.com/sunoc/xilinx-kria-kv260-\
  documentation/-/raw/main/src/custom_r5f_colcon.meta

  cp -r /armr5-toolchain/ \$(pwd)/firmware/toolchain && \
  export PATH=\$PATH:\$(pwd)/firmware/toolchain/bin

  ros2 run micro_ros_setup build_firmware.sh \
  \$(pwd)/custom_r5f_toolchain.cmake \$(pwd)/\
  custom_r5f_colcon.meta
#+END_SRC
#+LATEX: \pagebreak

* Including micro-ROS to the real-time firmware
Now we have a Vitis demonstration project available and the ~libmicroros~ static library
available, we can combine both by including this library into our Kria project.

On the host machine running the IDE, we can download the static library
and the include files from the Docker builder.
Here, we assume your Vitis IDE workspace sits in you home directory, at ~~/workspace~,
and that the Docker container is named ~ros_build~:
#+BEGIN_SRC sh
  mkdir /home/$USER/workspace/microros_lib

  docker cp ros_build:/microros_ws/firmware/build/\
         libmicroros.a /home/$USER/workspace/microros_lib/

  docker cp ros_build:/microros_ws/firmware/build/include \
         /home/$USER/workspace/microros_lib/
#+END_SRC

Many parameters are available to be set up in the IDE for the compilation toolchain, but
the figures [[fig:include]] and [[fig:include2]] below will show you a setup that worked to have the IDE
to recognize the include files and to be able to use them for compiling the firmware.

#+ATTR_LATEX: :width .8\textwidth
#+CAPTION: Firstly, in the "C/C++ Build" settings of your firmware project,
#+CAPTION: under the "Settings" menu, you should find the gcc compiler "Directories".
#+CAPTION: In here you should add the "include" directory of your library.
#+CAPTION: Be careful however, if your include files are in a second layer of directory
#+CAPTION: (as it is the case for libmicroros) you will need to include each sub-directory individually,
#+CAPTION: as visible in this figure.
#+NAME: fig:include
[[file:./img/vitis_new/include.png]]

#+ATTR_LATEX: :width .8\textwidth
#+CAPTION: Secondly, in the gcc linkers "Libraries", you can add the top level directory of your library.
#+CAPTION: In our case, it is the directory that contains both the "include" directory added earlier,
#+CAPTION: and also the "libmicroros.a" file.
#+NAME: fig:include2
[[file:./img/vitis_new/include2.png]]

#+LATEX: \pagebreak
With both of these setup in your project and as a minimal test to see if the setup was made correctly,
you should be able to include the following micro-ROS libraries into your project:
#+BEGIN_SRC C
  #include <rcl/rcl.h>
  #include <rcl/error_handling.h>
  #include <rclc/rclc.h>
  #include <rclc/executor.h>
#+END_SRC

The details for the inclusions and the use-case of the library will depend on the implementation
of the firmware itself.

But in general, as the firmware is successfully built and an ~.elf~ file is available and can be uploaded as a
firmware to the Kria board (or any remote server accessible through ~SSH~, for that matter) with the following
command[fn:10]:
#+BEGIN_SRC sh
  scp /home/sunoc/workspace/rpmsg_pingpong_microros_lib/\
      Debug/rpmsg_pingpong_microros_lib.elf  ubuntu@192.168.1.10:/home/ubuntu/
#+END_SRC
#+LATEX: \pagebreak

* micro-ROS adaptation for the firmware
Beyond the inclusion of the library itself, actually using the micro-ROS system
within an external project require more than just importing the needed
functions.

Indeed, if you would be just adding the various function for sending messages to
the general ROS2 network, you would face issues with four key aspects.
These are presented in the following dedicated sub-sections.

** Time functions
As micro-ROS can be used on a variety of board, it does not understand by itself
what time functions are meant to be used.

In that regard, some API-style function are being
used in the library and it is then needed for the person using a new board
to implement these function inner working using the board own time-related
function calls.

In particular for this part, the ~clock_gettime~ function is key, and could
simply be implemented with some FreeRTOS time functions.

The end result for these implementation are visible in the appendix [[Firmware time functions]],
and can be reused as-if for the Kria board setups.

** Memory allocators
Similarly to the time function, it is required to re-implement some form of memory allocating
functions in order for the library to be able to work with such functions in a formalized way.

As for now, the current version of the allocator function can be seen in the
appendix [[Firmware memory allocation functions]], but the current setup is not
completely "clean", some further formatting, test and modification will be needed.

** Custom transport layer                                    :WORK_IN_PROGRESS:
This part is the key translation layer that needs to happen in order for the
DDS system from the micro-ROS library to be using the communication channel we
want it to.

A problem that we had to figure out lives in the fact that the operation of micro-ROS DDS
and the board's RPMsg communication system does not operate in the same fashion.

The former expects to have four functions ("open", "read", "write" and "close") that can
be called and used by the main system, while the latter relies on FreeRTOS callback
system, waiting on the service interrupt routine to be trigger by an incoming message.

This situation meant that we count not simple translate the communication layers from one
to another: a non-blocking polling and buffer system needed to be put into places.
The proposed solution that was implemented and that is currently being tested
is showed and detailed in the figure [[fig:rpmsg_fw_tasks]] below.

As this part of the firmware was developed and tested on it's own, the overall
implementation within the "real" ping-pong application is still a work in progress,
and further modifications are expected when the system will be more thoroughly tested.

#+ATTR_LATEX: :width 1\textwidth
#+CAPTION: Two tasks are being run concurrently in order to manage the
#+CAPTION: communication situation, with binary semaphore-based lock-unlock system.\\
#+CAPTION: The role of the micro-ROS task (right) is to make the four functions
#+CAPTION: ("open", "read", "write" and "close")  available and running the actual
#+CAPTION: software function. In this example, polling the read function and writing
#+CAPTION: back when something is receive (ping-pong function).
#+CAPTION: The use of the ~rpmsg_send()~ function is done directly from the micro-ROS task,
#+CAPTION: bypassing the RPMsg task in this situation.\\
#+CAPTION: In the libmicroros implementation currently being developed, the micro-ROS task
#+CAPTION: holds all the DDS and micro-ROS system, including the mentioned allocators function.\\
#+CAPTION: The RPMsg task (center) is used to firstly set the RPMsg communication
#+CAPTION: with the Linux side (left), then it stays locked until the ISR (interrupt service routine)
#+CAPTION: is triggered by an incoming message. The message is then passed to the micro-ROS
#+CAPTION: task using a buffer.\\
#+CAPTION: When a shutdown signal is received from the Linux, both functions will gracefully close
#+CAPTION: and are getting killed.
#+NAME: fig:rpmsg_fw_tasks
[[file:./img/rpmsg_fw_tasks.png]]

#+LATEX: \pagebreak
* Loading the firmware
Having a version of our ~.elf~ firmware (with or without the included
micro-ROS library) built and loaded onto our Kria's Linux, we want to load and run it
on the Cortex micro-controller side.

As a reminder, the firmware can be loaded from the host machine IDE workspace
to the Kria board through ~SSH~ using the following command:
#+BEGIN_SRC sh
  scp /home/sunoc/workspace/rpmsg_pingpong_microros_lib/\
      Debug/rpmsg_pingpong_microros_lib.elf  ubuntu@192.168.1.10:/home/ubuntu/
#+END_SRC

The following instructions will show how to use this binary file, and
in particular how to upload and start the firmware on the R5F real time core
from the Linux user-space[fn:11], to test a basic RPMsg setup[fn:12]:
#+BEGIN_SRC sh
  sudo -s
  mv image_echo_test /lib/firmware
  echo image_echo_test  > /sys/class/remoteproc/\
       remoteproc0/firmware
  echo start > /sys/class/remoteproc/remoteproc0/state
  echo_test
  echo stop > /sys/class/remoteproc/remoteproc0/state
#+END_SRC

In this setup you need to be careful for the name of the ~.elf~ binary to be exactly used
in the first ~mv~ and ~echo~ command. In this example, the binary would be named
~image_echo_test.elf~, and moved from ~$HOME~ to ~/lib/firmware~.

The debug of the firmware itself is done by reading the "printf" visible from the serial
return of the board (typically a ~/dev/ttyUSB1~), but two things are to be noted:
+ If the ~echo start~ command fails, either the previous firmware run was not stopped,
  or the new binary itself is impossible to run.
+ In general, if the ~echo_test~ runs, it means that everything is okay and that
  the RPMsg system worked successfully.
#+LATEX: \pagebreak

  
* Running a ROS2 node
This section as well as the next one are rather "separated" from the rest of the report, as
they are focused on the ROS2 system being used on the Kria board.

In this first section, the installation of ROS2 as a system will be presented, with
two different ways of approaching the problem.

As for the previous section, the figure [[fig:map_ros]] below shows what part
of the overall system we are talking about here.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The ROS2 middle (red border) runs on top of the Linux,
#+CAPTION: on the general-purpose core of the Kria board.
#+NAME: fig:map_ros
[[file:./img/map_ros.png]]

** On the host Linux ("bare-metal")
Since an Ubuntu distribution is installed on the board, the installation of ROS2
can be done[fn:13] in a standard way, using the repository.

An [[https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html][official documentation]] is provided with ROS2 themselves with a step-by-step guide on how to install
ROS2 on a Ubuntu system{}.
We will be following this guide here[fn:14].

Firstly, we need to update the locals, enable the universe Ubuntu repository,
get the key and add the repository for ROS2. This can be done as follow:
#+BEGIN_SRC sh
  locale  # check for UTF-8
  sudo apt update && sudo apt install -y locales
  sudo locale-gen en_US en_US.UTF-8
  sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
  export LANG=en_US.UTF-8
  locale  # verify settings

  sudo apt install -y software-properties-common
  sudo add-apt-repository universe
  sudo apt update && sudo apt install -y curl wget

  wget https://raw.githubusercontent.com/ros/rosdistro/master/ros.key
  sudo mv ros.key /usr/share/keyrings/ros-archive-keyring.gpg
#+END_SRC

Then, a thicc one-liner is available to add the ROS2 repository to our system:
#+BEGIN_SRC sh
  echo "deb [arch=$(dpkg --print-architecture) \
  signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] \
  http://packages.ros.org/ros2/ubuntu $(. \
  /etc/os-release && echo $UBUNTU_CODENAME) main" | \
  sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
#+END_SRC

It is then possible to install ROS2[fn:15] as follow:
#+BEGIN_SRC sh
  sudo apt update
  sudo apt upgrade -y
  sudo apt install -y ros-humble-desktop \
       ros-humble-ros-base \
       python3-argcomplete \
       ros-dev-tools
#+END_SRC

Once installed, it is possible to test the system with a provided example.
You need to open two terminals and log wish SSH onto the board, then running
respectively:
#+BEGIN_SRC sh
  source /opt/ros/humble/setup.bash
  ros2 run demo_nodes_cpp talker
#+END_SRC

And then:
#+BEGIN_SRC sh
  source /opt/ros/humble/setup.bash
  ros2 run demo_nodes_py listener
#+END_SRC

You should be able to see the first terminal sending "Hello world" messages,
and the second one receiving then.

** In a container (Docker)
As containers are used to test and build micro-ROS configurations,
running ROS2 in a Docker  is a great way to have a reproducible configuration
of you system.

This part of the guide will present how to install Docker on the
Kria board and then how to use it to deploy the latest version of ROS2.

*** Installing Docker on Ubuntu
It is possible to have a version of Docker installed simply by using the available repository,
but since we are on Ubuntu, a PPA is available from Docker in order to have the most up-to-date version.

Following [[https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository][the official documentation]], the following steps can be taken to install the latest version of
Docker on a Ubuntu system. The last command is meant to test the install.
If everything went smoothly, you should see something similar to what is presented
in the figure [[fig:hello-docker]] below, after the commands:

#+BEGIN_SRC sh
  sudo apt-get update
  sudo apt-get install ca-certificates curl sudo
  gnupg install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
      sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

  sudo chmod a+r /etc/apt/keyrings/docker.gpg

  echo \
      "deb [arch="$(dpkg --print-architecture)" \
    signed-by=/etc/apt/keyrings/docker.gpg] \
    https://download.docker.com/linux/ubuntu \
    "$(. /etc/os-release && \
           echo "$VERSION_CODENAME")" stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

  sudo apt-get update
  sudo apt-get install docker-ce docker-ce-cli \
       containerd.io docker-buildx-plugin docker-compose-plugin
  sudo usermod -aG docker $USER
  newgrp docker

  docker run hello-world
#+END_SRC

#+ATTR_LATEX: :width .7\textwidth
#+CAPTION: The return of a successful run of the ~hello world~ test Docker container.
#+NAME: fig:hello-docker
[[file:./img/hello-docker.png]]


*** Running a ROS2 container
The following commands will pull a ROS container, version ~iron~, and name it ~ros_build~.

A key part for having access to the interfaces (serial) is the mapping of the whole ~/dev~
range of devices from the host machine to the internal ~/dev~ of the container[fn:16].
With the second command, we can execute ~bash~ as a way to open a terminal to the "inside" the container:
#+BEGIN_SRC sh
  docker run -d --name ros_agent -it --net=host -v \
         /dev:/dev --privileged ros:iron
  docker exec -it ros_agent bash
#+END_SRC

From there, it becomes possible to simply use ROS2 as you would for a bare-metal install,
and as presented in the section [[On the host Linux ("bare-metal")]] above:
#+BEGIN_SRC sh
  source /opt/ros/$ROS_DISTRO/setup.bash

  # Create a workspace and download the micro-ROS tools
  mkdir microros_ws
  cd microros_ws
  git clone -b $ROS_DISTRO https://github.com/micro-ROS/\
      micro_ros_setup.git src/micro_ros_setup

  # Update dependencies using rosdep
  sudo apt update && rosdep update
  rosdep install --from-paths src --ignore-src -y

  # Install pip
  sudo apt-get install python3-pip

  # Build micro-ROS tools and source them
  colcon build

  # Download micro-ROS-Agent packages
  source install/local_setup.bash
  ros2 run micro_ros_setup create_agent_ws.sh

  # Build step
  ros2 run micro_ros_setup build_agent.sh

  # Run a micro-ROS agent
  ros2 run micro_ros_agent micro_ros_agent serial \
       --dev /dev/ttyUSB1
#+END_SRC

Then once again in a similar way to the bare-metal deployment,  it is possible to run a demonstration
the ping-pong topic communication from a different shell[fn:17]:
#+BEGIN_SRC sh
  source /opt/ros/$ROS_DISTRO/setup.bash

  # Subscribe to micro-ROS ping topic
  ros2 topic echo /microROS/ping
#+END_SRC
#+LATEX: \pagebreak


* micro-ROS agent                                             :WORK_IN_PROGRESS:
The micro-ROS agent on the ROS2 side is the last piece of the puzzle needed to
allow our DDS environment to use RPMsg as a mean of communication, as visible
on the schematic of the figure [[fig:map_agent]] below.
In particular, it will be useful to modify this agent in order to archive
the full RPMsg communication for ROS2[fn:19].
An [[https://micro.ros.org/docs/tutorials/advanced/create_custom_transports/][official documentation]] exists, but it gives little to no detail
on how to deploy such modified, custom transport setup.
This part of the guide will focus on it.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The agent (red border) allows for a micro-ROS
#+CAPTION: instance to communicate with a ROS2 system.
#+CAPTION: It is deployed on the Linux side, as a ROS2 node.
#+NAME: fig:map_agent
[[file:./img/map_agent.png]]


** Building a eProsima agent bare-metal
A key aspect to understand about modifying the agent (as
this will be needed later on to support our new communication system),
is that the default system and instruction provided by micro-ROS does not
allow such modification[fn:18].

In order to avoid that, one can get and run a ROS2 node design by eProsima,
that can be deployed on it's own (without other ROS2 application and nodes)
and eventually modified.


#+BEGIN_SRC sh
  sudo nano /microros_ws/build/micro_ros_agent/agent/src/xrceagent/src/cpp/transport/custom/CustomAgent.cpp
#+END_SRC
The same file is available online as a reference, on [[https://github.com/eProsima/Micro-XRCE-DDS-Agent/blob/develop/src/cpp/transport/custom/CustomAgent.cpp][eProsima XRCE-DDS-Agent GitHub repository]].


#+BEGIN_SRC sh
  git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
  cd Micro-XRCE-DDS-Agent/

  rm -rf examples/
  git clone https://gitlab.com/sunoc/rpmsg-micro-ros-agent.git ./examples/custom_agent

  mkdir build && cd build
  cmake -DUAGENT_BUILD_USAGE_EXAMPLES=ON ..
  make
#+END_SRC

The custom agent is then available to run from the ~./src/examples/custom_agent/CustomXRCEAgent~.

All the diff when the custom agent system was added:
https://github.com/eProsima/Micro-XRCE-DDS-Agent/pull/205/files

For rebuilding the custom agent with a simple ~make clean && make all~ will
conveniently only rebuild the part that was modify.
Which means that once all the libraries have been compiled once,
the subsequent re-compilation of the agent itself can be done quickly !

Major details on how to implement a custom agent specified here:
https://github.com/eProsima/Micro-XRCE-DDS-Agent/issues/195#issuecomment-721002153

# Running the custom agent executable can be executed as is as the transport we want to use is already
# built in. ~kmod~ package is needed though.
# #+BEGIN_SRC sh
#   sudo apt-get update
#   sudo apt-get install kmod
#     ./examples/custom_agent/CustomXRCEAgent
# #+END_SRC


** Building the XRCE-DDS agent in a Docker
The same command presented above for running a custom agent "bare-metal" can be
run inside a Docker.

#+BEGIN_SRC sh
  docker run -d --name XRCE_DDS_Agent -it --net=host -v \
         /dev:/dev --privileged ros:iron
  docker exec -it XRCE_DDS_Agent bash
#+END_SRC


#+BEGIN_SRC sh
  git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
  cd Micro-XRCE-DDS-Agent
  docker build -t xrce-dds-agent .
  docker run -it --privileged -v /dev:/dev xrce-dds-agent serial \
         --dev /dev/ttyACM0
#+END_SRC


** Creating a custom transport agent


#+LATEX: \pagebreak


* Conclusion & future                                         :WORK_IN_PROGRESS:

#+LATEX: \pagebreak
#+LATEX: \appendix


* DTO patch
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch][system.patch]]
#+LATEX: \inputminted[linenos, frame=single]{diff}{./src/system.patch}

#+LATEX: \pagebreak
* Custom toolchain CMake settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_toolchain.cmake][custom r5f toolchain.cmake]]
#+LATEX: \inputminted[linenos, frame=single]{cmake}{./src/custom_r5f_toolchain.cmake}

#+LATEX: \pagebreak
* Custom Colcon meta settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_colcon.meta][custom r5f colcon.meta]]
#+LATEX: \inputminted[linenos, frame=single]{yaml}{./src/custom_r5f_colcon.meta}

#+LATEX: \pagebreak
* Firmware time functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/clock.c][clock.c]]
but a potentially more up-to-date version is visible
directly at the ~libmicroros_kv260~ repository: [[https://gitlab.com/sunoc/libmicroros_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/clock.c][clock.c]]

#+LATEX: \inputminted[linenos, frame=single]{c}{./src/clock.c}

** header file
#+BEGIN_SRC C
  /**< Microseconds per second. */
  #define MICROSECONDS_PER_SECOND    ( 1000000LL )  
  /**< Nanoseconds per second. */
  #define NANOSECONDS_PER_SECOND     ( 1000000000LL ) 
  /**< Nanoseconds per FreeRTOS tick. */  
  #define NANOSECONDS_PER_TICK       ( NANOSECONDS_PER_SECOND / configTICK_RATE_HZ ) 
#+END_SRC


#+LATEX: \pagebreak
* Firmware memory allocation functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/allocators.c][allocators.c]]
but a potentially more up-to-date version is visible
directly at the ~libmicroros_kv260~ repository: [[https://gitlab.com/sunoc/libmicroros_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/allocators.c][allocators.c]]

#+LATEX: \inputminted[linenos, frame=single]{c}{./src/allocators.c}

** header file
#+BEGIN_SRC C
  #ifndef _ALLOCATORS_H_
  #define _ALLOCATORS_H_

  #include "microros.h"

  extern int absoluteUsedMemory;
  extern int usedMemory;


  void * __freertos_allocate(size_t size, void * state);
  void __freertos_deallocate(void * pointer, void * state);
  void * __freertos_reallocate(void * pointer, size_t size, void * state);
  void * __freertos_zero_allocate(size_t number_of_elements,
  size_t size_of_element, void * state);

  #endif // _ALLOCATORS_H_
#+END_SRC


* Footnotes

[fn:19] This will be done with ROS2 agents "custom transport"  system,
which has little documentation. Some [[https://github.com/micro-ROS/micro_ros_setup/issues/383][discussions]] about it exist though.

[fn:18] This information was eventually found on a discussion in a [[https://github.com/micro-ROS/micro_ros_setup/issues/591][GitHub Issue thread]]. 

[fn:17] You need to be careful to have you shell in the "correct" space: these command need to be run inside
the container in which the previous setup were install, not on the host running the container system.
The hostname should help you to figure out where you are.

[fn:16] This is an example and this situation can become a security issue. It would be a better practice
in a production environment to map only the devices that are actually in use. 

[fn:15] This command installs a complete "desktop" version of ROS2, containing many
useful package for our project.
If space is a constraint, different, less complete packages can be install.
Please refer to the official documentation about it. 

[fn:14] The ~curl~ command from the guide does not work through the school proxy,
but the command ~wget~ used instead does work. The key is then moved to the correct spot with ~mv~. 

[fn:13] As always, this configuration was tested solely on Ubuntu LTS 22.04,
with the ROS2 versions ~Humble~ and then ~Iron~ being deployed.
Other combination of versions should work as well, but they are not
tested for this guide. In case of doubt or problem, please refer to the official documentation. 

[fn:12] It is also important to note that the ~echo_test~ part is specific for the
RPMsg base demonstration firmware. It is not to be used for other firmware.
The instruction to build and use this particular program on the Kria Linux
is visible in the section [[RPMsg ~echo_test~ software]]. 

[fn:11] In this sequence, we are entering a root shell with ~sudo -s~, but this can
also be archived by putting the commands in a script to be executed with ~sudo~. 

[fn:10] Note that in that case, we are retrieving the binary for a project
named ~rpmsg_pingpong_microros_lib~.
You own path will vary depending on how your project was named in the first place.
Obviously, the ~SSH~ connection parameters will also be specific to your case.
The ~ubuntu@192.168.1.10~ set here are merely an example.

[fn:9] Both files are also visible in the appendixes [[Custom toolchain CMake settings]]
and [[Custom Colcon meta settings]] the end of this report.} 

[fn:8] If Docker is not set up on your machine, you can follow the guide on [[https://docs.docker.com/engine/install/ubuntu/][the official website]].
When you can successfully run the "hello-world" container, you are good to go.

[fn:7] The same procedure should work for other versions of Ubuntu, as long as they
support the Kria board, but for this report and project, only the LTS 22.04 was tested
(as of 2023-08-30).

[fn:6] The name of the installer binary file might change as a new version of the IDE
is release every year or so.

[fn:5] The overlapping memory will not prevent the board to boot,
but it disables the PWM for the CPU fan, which will then run at full speed, making noise. 

[fn:4] A [[https://zenn.dev/ryuz88/articles/kv260_setup_memo_ubuntu22 ][blog post]] (JP) shows all major steps on how to enable the ~remoteproc~.

[fn:3] A [[https://speakerdeck.com/fixstars/fpga-seminar-12-fixstars-corporation-20220727][slideshow]] (JP) from Fixstar employees presents how to use the device
  tree to enable the communication between the cores.

[fn:2] The ~snap~ packages depends on each others. Dependencies
cannot be remove before the package(s) that depends on them,
thus the specific delete order.

[fn:1] Again, it is _critical_ to be 100\% certain that you are working with
the correct device! 
