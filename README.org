:PROPERTIES:
:ID:       ac338634-949e-4e3a-8d75-45bed92243c6
:END:
#+title: Setting up and using 
#+title: Xilinx KRIA KV260
#+filetags: :export:
#+subtitle: \begin{CJK}{UTF8}{min}南山大学\end{CJK}
#+author: Vincent Conus
#+date: 2023-8-24



* Headers and LaTeX settings for export                               :noexport:
A large amount of headers and parameters are needed in order
to have this "README" document being exportable as a LaTeX
document formatted the way I wanted it to be.

The detail can be seen in the raw ~.org~ version of this README
and stays hidden in a :noexport: section in this report.

#+DESCRIPTION: A report presenting how to use and set Xilinx's Kria board
#+LANGUAGE: English

#+OPTIONS: toc:t date:t title:t

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:[10pt]
#+LATEX_HEADER: \usepackage[a4paper, total={6.5in, 9in}]{geometry}

#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{breaklines}
#+LATEX_HEADER: \usepackage[AUTO]{inputenc}
#+LATEX_HEADER: \renewcommand{\familydefault}{\sfdefault}
#+LATEX_HEADER: \usemintedstyle{vs}

#+LATEX_HEADER: \usepackage[most]{tcolorbox}

#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \usepackage{xurl}
#+LATEX_HEADER: \usepackage{fontawesome5}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{float}

#+LATEX_HEADER: \newcommand{\gitlab}[1]{%
#+LATEX_HEADER:    \href{#1}{GitLab \faGitlab}}

#+begin_src emacs-lisp :exports results :results none :eval export
  (make-variable-buffer-local 'org-latex-title-command)
  (setq org-latex-title-command (concat
     "\\begin{titlepage}\n"
     "\\centering\n"
     "{\\LARGE %t \\par }\n"
     "\\vspace{5mm}\n"
     "{\\large %s \\par}\n"
     "\\vspace{1cm}\n"
     "{\\large %D \\par}\n"
     "\\vspace{2cm}\n"
     "{\\large %a -  Source available at \\gitlab{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation} \\par}\n"
     "\\vspace{3cm}\n"
     "\\includegraphics[width=0.8\\textwidth]{./img/board}"
     "\\end{titlepage}\n"))
#+end_src

#+begin_src emacs-lisp :exports results :results none :eval export
    (make-variable-buffer-local 'org-latex-toc-command)
    (setq org-latex-toc-command (concat
       "\\tableofcontents\n"
       "\\pagebreak\n"))
#+end_src

* Building this report from the LaTeX file                            :noexport:
The base file for this report is actually this README.org file itself.
However, upon local build, this file is regularly exported as
a ~.tex~ file that can be built normally.
On a moderately recent Ubuntu-base distribution, the following packages seemed to be required to build the
report:

#+BEGIN_SRC bash
  sudo apt-get install texlive-base texlive-latex-recommended texlive-lang-japanese
#+END_SRC

Then, the actual build can be made with a simple:

#+BEGIN_SRC bash
  pdflatex README.tex
#+END_SRC

* Introduction & motivation
This guide will present how to setup and use Xilinx's KRIA board, in particular
for running ROS on a host Ubuntu system, as well as for deploying
micro-ROS as a firmware on the MCU part of this board's chip.

The use of this device in particular is interesting because of the presence
of a CPU comprising both a general purpose ARM core, capable of running
a Linux distribution, as well as another ARM core, real-time enabled,
capable to run a RTOS.

* Boot firmware
The goal for the Linux side of the deployment is to
have the latest LTS version of Ubuntu up and running.
In order to be able to boot such a newer version of Linux, the
boot image of the board must first be updated.

The procedure is available in [[https://docs.xilinx.com/r/en-US/ug1089-kv260-starter-kit/Firmware-Update][the official documentation]],
but I will present it step by step here.

** Getting the new firmware
A 2022 version of the board firmware is required in order to run the latest
version of Ubuntu properly.

The image can be downloaded at [[https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+K26+
SOMoot-FW-update-with-xmutil][the atlassian page]] on the topic,
or even directly with the following command:

#+BEGIN_SRC sh
  wget https://www.xilinx.com/member/forms/download/\
       design-license-xef.html?filename=BOOT-k26-starter-kit-20230516185703.bin
#+END_SRC


** Reaching the board recovery tool
Now the firmware ~.bin~ image is available, it is possible to update it using the
boards recovery tool. Here are the steps that must be taken in order to reach
this tool and update the board:

+ Connect the board to your machine via a Ethernet cable.
  This will obviously cut you internet access, so you should be set for that.
+ Select the wired network as your connection (must be "forced", since it
  doesn't have internet access).
+ Set a fixed IP address for your machine, in the ~192.168.0.1/24~
  range, except the specific ~192.168.0.111~, which will be used by the
  board.
+ Using a web browser on your host machine, access
  ~http://192.168.0.111~. Thou shall now see the interface, as visible on
  the figure [[fig:recovery]] below.

#+ATTR_LATEX: :width 1\textwidth
#+CAPTION: The recovery tool for the board, access from Firefox. We can see
#+CAPTION: board information at the center, and the tools to upload the firmware at
#+CAPTION:   the bottom of the page.
#+NAME: fig:recovery
[[file:img/recovery.png]]

** Updating the boot firmware
From this "recovery" page, it is possible to upload the ~.bin~ file downloaded previously onto
the board using the "Recover Image" section at the bottom right of the page.

The board can be re-booted afterwards.

* Installing Linux
Withe the boot firmware being up-to-date, we can proceed to install a Linux distribution
on our Kria board. The step needed to archive a full installation of Ubuntu 22.04
will be presented in this section.

** Preparing and booting a Ubuntu 22.04 media
An [[https://ubuntu.com/download/amd-xilinx][official Ubuntu image]] exists and is
provided by Xilinx, allowing the OS installation to be quick and
straightforward.
Ubuntu is a common and easy to use distribution. Furthermore,
it allows to install ROS2 as a package, which is most convenient and will be
done later in this guide.

Once the image has been downloaded at [[https://ubuntu.com/download/amd-xilinx][Canonical's page]]
we can flash it onto the SD card, with the following instructions.

#+LATEX: \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
*DANGER*: The next part involve the ~dd~ command writing on disks!!!
As always with the dd command, thou have to be *VERY* careful on what arguments
thou give. Selecting the wrong disk will result on the destruction of
thy data !!
_If you are unsure of what to do, seek assistance !_
#+LATEX: \end{tcolorbox}

With the image available on thy machine and a SD card visible as ~/dev/sda~
[fn:1] one can simply run the ~dd~ command as follow to
write the image to a previously formatted drive (here ~/dev/sda~):

#+BEGIN_SRC sh
  sudo dd if=iot-limerick-kria-classic-desktop-2204-x07-20230302-63.img \
  of=/dev/sda status=progress bs=8M && sync
#+END_SRC


Once the SD card is flashed and put back in the board, the micro-USB cable can be
connected from the PC to the board. It is then possible to
connect to the board in serial with an appropriate tool, for example ~picocom~,
as in the following example (the serial port that "appeared" was the ~/dev/ttyUSB1~ in this case,
and the 115200 bitrate is the default value for the board):

#+BEGIN_SRC sh
  sudo picocom /dev/ttyUSB1 -b 115200
#+END_SRC

Once logged in, it is typically easier and more convenient to connect the board
using SSH. When the board is connected to the network, it is possible to know
it's IP address with the ~ip~ command; then it is possible to connect to
the board with ssh, as follow (example, with the first command to be run on the board
and the second one on the host PC, both without the first placeholder hostnames):


#+BEGIN_SRC sh
  kria# ip addr

  host# ssh ubuntu@192.168.4.11
#+END_SRC

** Network and admin setups
This section presents a variety of extra convenience configurations
that can be used when setting-up the Kria board.

*** Proxy and DNS
An issue that can occur when connecting the board to the internet is the
conflicting situation with the university proxy.
Indeed, as the network at Nanzan University requires to go through a proxy,
some DNS errors appeared.

Firstly, it is possible to set a DNS IP address in ~/etc/resolv.conf~ by
editing it and adding your favorite DNS, for example ~nameserver 1.1.1.1~
next to the other ~nameserver~ entry. The resolver can then be restarted.

#+BEGIN_SRC sh
  sudo nano /etc/resolv.conf

  sudo systemctl restart systemd-resolved
#+END_SRC

Secondly, it might become needed to setup the proxy for the school.

This can be done as follow, by exporting a https base proxy configuration
containing you AXIA credentials (this is specific to Nanzan University IT system),
then by consolidating the configuration for other types of connections in the ~bashrc~:

#+BEGIN_SRC sh
  export https_proxy="http://<AXIA_username>:\
         <AXIA_psw>@proxy.ic.nanzan-u.ac.jp:8080"

  echo "export http_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export https_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export ftp_proxy=\""$https_proxy"\"" >> ~/.bashrc \
       echo "export no_proxy=\"localhost, 127.0.0.1,::1\"" \
       >> ~/.bashrc
#+END_SRC

Eventually the board can be rebooted in order for the setup to get applied cleanly.

*** ~root~ password
#+LATEX: \begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
*WARNING*: Depending on your use-case, the setup presented in this
subsection can be a critical security breach as it remove the need for a root
password to access the admin functions of the board's Linux.
_When in doubt, do not apply this configuration!!_
#+LATEX: \end{tcolorbox}

If you board does not hold important data
and is available to you only, for test or development,
it might be convenient for the ~sudo~ tool to not ask for the
password all the time.
This change can be done by editing the sudoers file, and
adding the parameter ~NOPASSWD~
at the ~sudo~ line:

#+BEGIN_SRC sh
sudo visudo

%sudo   ALL=(ALL:ALL) NOPASSWD: ALL
#+END_SRC

Again, this is merely a convenience setup for devices staying at you desk. If
the board is meant to be used in any kind of production setup, a password
should be set for making administration tasks.

With all of these settings, you should be able to update the software of your
board without any issues:
#+BEGIN_SRC sh
sudo apt-get update
sudo apt-get dist-upgrade
sudo reboot now
#+END_SRC


*** Static IP address
A static IP can be set by writing the following
configuration into your ~netplan~ configuration file.

The name of the files might vary:
#+BEGIN_SRC sh
  sudo nano /etc/netplan/50-cloud-init.yaml
#+END_SRC

You can then set the wanted IP as follow. Note that a custom DNS was
also set in that case.
#+BEGIN_SRC yaml
  network:
    renderer: NetworkManager
    version: 2
    ethernets:
      eth0:
        addresses:
          - 192.168.11.103/24
        routes:
          - to: default
            via: 192.168.11.1
        nameservers:
          addresses:
            - 8.8.8.8
            - 1.1.1.1
#+END_SRC

Finally, the change in settings can be applied
as follow:

#+BEGIN_SRC sh
  sudo netplan apply
#+END_SRC

*** Purging ~snap~
As the desktop-specific software are not used at all in the case
of our project, there are some packages that can be purges in order for the
system to become more lightweight.

In particular, the main issue with Ubuntu systems is the forced integration of
Snap packages. Here are the command to use in order to remove all of that.
These steps take a lot of time and need to be executed in that specific order[fn:2],
but the system fan runs sensibly slower without all of this stuff:

#+BEGIN_SRC sh
  sudo systemctl disable snapd.service
  sudo systemctl disable snapd.socket
  sudo systemctl disable snapd.seeded.service

  sudo snap list #show installed package, remove then all:
  sudo snap remove --purge firefox
  sudo snap remove --purge gnome-3-38-2004
  sudo snap remove --purge gnome-42-2204
  sudo snap remove --purge gtk-common-themes
  sudo snap remove --purge snapd-desktop-integration
  sudo snap remove --purge snap-store
  sudo snap remove --purge bare
  sudo snap remove --purge core20
  sudo snap remove --purge core22
  sudo snap remove --purge snapd
  sudo snap list # check that everything is uninstalled

  sudo rm -rf /var/cache/snapd/
  sudo rm -rf ~/snap
  sudo apt autoremove --purge snapd

  systemctl list-units | grep snapd
#+END_SRC

*** Other unused heavy packages
Some other pieces of software can safely be removed since the desktop is
not to be used:

#+BEGIN_SRC sh
  sudo apt-get autoremove --purge yaru-theme-icon \
  fonts-noto-cjk yaru-theme-gtk vim-runtime \
  ubuntu-wallpapers-jammy humanity-icon-theme

  sudo apt-get autoclean
  sudo reboot now
#+END_SRC

* Enabling ~remoteproc~
One of the advantage of this Kria board, as cited previously, is the presence of
multiple types of core (APU, MCU, FPGA) on the same chip.

The part in focus in this guide is the usage of both the APU, running
a Linux distribution and ROS2; and the MCU, running FreeRTOS and micro-ROS.
Online available guides[fn:3] [fn:4] also provide information on how to deploy these types
of systems and enabling ~remoteproc~ for the Kria board, but this guide
will show a step-by-step, tried process to have a heterogeneous system
up and running.

The communication between both side is meant to be done using shared memory, but
some extra setup is required in order to be running the real-time firmware, in particular
for deploying micro-ROS on it.

As a first step in that direction, this section of the report
will present how to setup and use as an example firmware that utilizes the
~remoteproc~ device in Linux in order to access shared memory
and communicate with the real-time firmware using the RPMsg system.

** Device-Tree Overlay patching
The communication system and interaction from the Linux side towards the real-time capable core
is not enabled by default within the Ubuntu image provided by Xilinx.

In that regard, some modification of the device tree overlay (DTO) is required in order to have
the ~remoteproc~ system starting.

Firstly, we need to get the original firmware device tree, converted
into a readable format (DTS):

#+BEGIN_SRC sh
  sudo dtc /sys/firmware/fdt 2> /dev/null > system.dts
#+END_SRC

Then, a custom-made patch file can be downloaded and applied.
This file is available at the URL visible in the command below
but also in this report appendix [[DTO patch]].

#+BEGIN_SRC sh
  wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/\
       blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch

  patch system.dts < system.patch
#+END_SRC

As for the board to be able to reserve the correct amount of memory with the new settings, some
~cma~ kernel configuration is needed[fn:5]:

#+BEGIN_SRC sh
  sudo nano /etc/default/flash-kernel

  LINUX_KERNEL_CMDLINE="quiet splash cma=512M cpuidle.off=1"
  LINUX_KERNEL_CMDLINE_DEFAULTS=""
  sudo flash-kernel
#+END_SRC

Now the DTS file has been modified, one can regenerate the binary and place it on the ~/boot~ partition
and reboot the board:

#+BEGIN_SRC sh
  dtc -I dts -O dtb system.dts -o user-override.dtb
  sudo mv user-override.dtb /boot/firmware/
  sudo reboot now
#+END_SRC

After rebooting, you can check the content of the \verb|remoteproc| system directory,
and a ~remoteproc0~ device should be visible, as follow:

#+BEGIN_SRC sh
  ls /sys/class/remoteproc/
  #  remoteproc0
#+END_SRC

If it is the case, it means that the patch was successful and  that the remote processor is
ready to be used!

* Building an example RPMsg real-time firmware
As visible on the official [[https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1837006921/OpenAMP+Base+Hardware+Configurations\#Build-RPU-firmware][Xilinx documentation about building a demo firmware]],
this section will present the required steps for building a new firmware for the R5F
core of our Kria board.

The goal here is to have a demonstration firmware running,
able to use the RPMsg system to communicate with the Linux APU.

** Setting up the IDE
Xilinx's Vitis IDE is the recommended tool used to build software for the Xilinx boards.
It also include the tools to interact with the FPGA part, making the whole
software very large (around 200GB of disk usage).

However, this large tool-set allows for a convenient development environment, in particular
in our case where some FreeRTOS system, with many dependencies is to be build.

The installer can be found on [[https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html][Xilinx download page]]. You will need to get
a file named something like ~Xilinx_Unified_2022.2_1014_8888_Lin64.bin~[fn:6].

Vitis IDE installer is compatible with versions of Ubuntu, among other distributions,
but not officially yet for the 22.04 version.
Furthermore, the current install was tested on Pop OS, a distribution derived from Ubuntu.
However, even with this more unstable status, no major problems were encountered
with this tool during the development stages.

This guide will present a setup procedure that supposedly works for all distributions based on the newest
LTS from Ubuntu. For other Linux distributions or operating system, please refer to the official documentation.

*** Dependencies & installation
Some packages are required to be installed on the host system
in order for the installation process to happen successfully:

#+BEGIN_SRC sh
  sudo apt-get -y update

  sudo apt-get -y install libncurses-dev \
       ncurses-term \
       ncurses-base \
       ncurses-bin \
       libncurses5 \
       libtinfo5 \
       libncurses5-dev \
       libncursesw5-dev
#+END_SRC

Once this is done, the previously downloaded binary installer can be executed:

#+BEGIN_SRC sh
  ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
#+END_SRC

If it is not possible to run the previous command, make the file executable with the ~chmod~ command:

#+BEGIN_SRC sh
  sudo chmod +x ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
#+END_SRC

From there you can follow the step-by-step graphical installer.
The directory chosen for the rest of this guide for the Xilinx directory
is directly the ~$HOME~, but the installation can be set elsewhere is needed.

#+LATEX: \begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
*WARNING*: This whole procedure can take up to multiple hours to complete
and is prone to failures (regarding missing dependencies, typically),
so your schedule should be arranged accordingly.
#+LATEX: \end{tcolorbox}

*** Platform configuration file generation
In order to have the libraries and configurations in the IDE ready to be used for our board,
we need to obtain some configuration files that are specific for the Kria KV260,
as presented in the [[https://xilinx.github.io/kria-apps-docs/kv260/2022.1/build/html/docs/build_vitis_platform.html?highlight=xsa][Xilinx guide for Kria and Vitis]].

A Xilix [[https://github.com/Xilinx/kria-vitis-platforms][dedicated repository]] is available for us to download  such configurations,
but they required to be built.

As for the dependencies, ~Cmake~, ~tcl~ and ~idn~ will become needed in order to build the firmware.
Regarding ~idn~, some version issue can happen, but as discussed [[https://support.xilinx.com/s/question/0D52E00006jrzsYSAQ/platform-project-cannot-be-created-on-vitis?language=en\_US][in a thread on Xilinx's forum]],
if ~libidn11~ is specifically required but not available (it is the case for Ubuntu 22.04),
creating a symbolic link from the current, 12 version works as a workaround.

Here are the steps for installing the dependencies and building this configuration file:

#+BEGIN_SRC sh
  sudo apt-get update
  sudo apt-get install cmake tcl libidn11-dev \
  libidn-dev libidn12 idn
  sudo ln -s /usr/lib/x86_64-linux-gnu/libidn.so.12 \
  /usr/lib/x86_64-linux-gnu/libidn.so.11

  cd ~/Xilinx
  git clone --recursive \
  https://github.com/Xilinx/kria-vitis-platforms.git
  cd kria-vitis-platforms/k26/platforms
  export XILINX_VIVADO=/home/$USER/Xilinx/Vivado/2022.2/
  export XILINX_VITIS=/home/$USER/Xilinx/Vitis/2022.2/
  make platform PLATFORM=k26_base_starter_kit
#+END_SRC


** Setting up and building a new project for the Kria board
With the platform configuration files available, we can now use the IDE to generate a
new project for our board. The whole process will be described with screen captures and
captions.

#+ATTR_LATEX: :width .5\textwidth
#+CAPTION: We are starting with creating a "New Application Project"
#+CAPTION: You should be greeted with this wizard window. Next.
#+NAME: fig:project1
[[file:./img/vitis_new/project1.png]]

#+ATTR_LATEX: :width .5\textwidth
#+CAPTION: For the platform, we need to get our build Kria configuration.
#+CAPTION: In the "Create a new platform" tab,
#+CAPTION: click the "Browse..." button.
#+NAME: fig:project2
[[file:./img/vitis_new/project2.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In the file explorer, we should navigate in the "k26" directory,
#+CAPTION: where the configuration file was build.
#+CAPTION: From here we are looking for a ".xsa" file, located in a "hw" directory, as visible.
#+NAME: fig:project3
[[file:./img/vitis_new/project3.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: With the configuration file loaded, we can now select a name for our
#+CAPTION: platform, but most importantly, we have to select the "psu Cortex5 0" core as a target.
#+CAPTION: The other, Cortex 53 is the APU running Linux.
#+NAME: fig:project4
[[file:./img/vitis_new/project4.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In this next window, we can give a name to our firmware project.
#+CAPTION: It is also critical here to select the core we want to build for.
#+CAPTION: Once again, we want to use the "psu cortex5 0".
#+NAME: fig:project5
[[file:./img/vitis_new/project5.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: Here, we want to select "freertos10 xilinx" as our Operating System.
#+CAPTION: The rest can remain unchanged.
#+NAME: fig:project6
[[file:./img/vitis_new/project6.png]]

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: Finally, we can select the demonstration template we are going to use;
#+CAPTION: here we go with "OpenAMP echo-test" since we want to
#+CAPTION: have some simple try of the RPMsg system. Finish.
#+NAME: fig:project7
[[file:./img/vitis_new/project7.png]]

#+LATEX: \pagebreak
In the Xilinx documentation, it is made mention of the addresses setting that should be checked in the ~script.ld~ file.
These valued look different from what could be set in the DTO for the Linux side, but they appear to
work for the example we are running:

#+BEGIN_SRC sh
  psu_ddr_S_AXI_BASEADDR                     0x3ed00000	
  psu_ocm_ram_1_S_AXI_BASEADDR        0xfffc0000
  psu_r5_tcm_ram_0_S_AXI_BASEADDR    0x00000000
  psu_r5_tcm_ram_1_S_AXI_BASEADDR    0x00020000	
#+END_SRC



#+LATEX: \pagebreak
* Building a real-time firmware

** Setting up Vitis IDE

* RPMsg ~echo_test~ software
In order to test the deployment of the firmware on the R5F side, and in particular
to test the RPMsg function, we need some program on the Linux side of the Kria
board to "talk" with the real-time side.

Some source is provided by Xilinx to build a demonstration software that does
this purpose: specifically interact with the demonstration firmware.

Here are the steps required to obtain the sources, and build the program.

As a reminder, this is meant to be done on the Linux running on the
Kria board, NOT on your host machine !

#+BEGIN_SRC sh
  git clone https://github.com/Xilinx/meta-openamp.git
  cd  meta-openamp
  git checkout xlnx-rel-v2022.2
  cd  ./recipes-openamp/rpmsg-examples/rpmsg-echo-test
  make
  sudo ln -s $(pwd)/echo_test /usr/bin/
#+END_SRC

Once this is done, it it possible to run the test program from the Kria board's Ubuntu
by running the ~echo_test~ command.

* Building micro-ROS as a static library


#+BEGIN_SRC sh
  pushd /home/$USER/Downloads
  wget https://developer.arm.com/-/media/Files/downloads/\
  gnu/12.2.mpacbti-rel1/binrel/arm-gnu-toolchain-12.2\
  .mpacbti-rel1-x86_64-arm-none-eabi.tar.xz
  tar -xvf arm-gnu-toolchain-12.2.mpacbti-rel1-x86_64-\
  arm-none-eabi.tar.xz
  popd

  toolchain="/home/$USER/Downloads/arm-gnu-toolchain-\
  12.2.mpacbti-rel1-x86_64-arm-none-eabi/"


  docker run -d --name ros_build -it --net=host \
  --hostname ros_build \
  -v /dev:/dev \
  -v $toolchain:/armr5-toolchain \
  --privileged ros:iron

  docker exec -it ros_build bash
#+END_SRC

* Adding micro-ROS to a firmware project

* Loading a real-time firmware 

* Running a ROS2 node

** On the host Linux

** In a container

* micro-ROS agent

#+LATEX: \pagebreak
#+LATEX: \appendix
* DTO patch
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch][system.patch]]
#+LATEX: \inputminted[linenos, frame=single]{diff}{./src/system.patch}

#+LATEX: \pagebreak
* Custom toolchain CMake settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_toolchain.cmake][custom r5f toolchain.cmake]]
#+LATEX: \inputminted[linenos, frame=single]{cmake}{./src/custom_r5f_toolchain.cmake}

#+LATEX: \pagebreak
* Custom Colcon meta settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_colcon.meta][custom r5f colcon.meta]]
#+LATEX: \inputminted[linenos, frame=single]{yaml}{./src/custom_r5f_colcon.meta}

#+LATEX: \pagebreak
* Firmware time functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/clock.c][clock.c]]
#+LATEX: \inputminted[linenos, frame=single]{c}{./src/clock.c}

** header file
#+BEGIN_SRC C
  /**< Microseconds per second. */
  #define MICROSECONDS_PER_SECOND    ( 1000000LL )  
  /**< Nanoseconds per second. */
  #define NANOSECONDS_PER_SECOND     ( 1000000000LL ) 
  /**< Nanoseconds per FreeRTOS tick. */  
  #define NANOSECONDS_PER_TICK       ( NANOSECONDS_PER_SECOND / configTICK_RATE_HZ ) 
#+END_SRC


#+LATEX: \pagebreak
* Firmware memory allocation functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/allocators.c][allocators.c]]
#+LATEX: \inputminted[linenos, frame=single]{c}{./src/allocators.c}

** header file
#+BEGIN_SRC C
  #ifndef _ALLOCATORS_H_
  #define _ALLOCATORS_H_

  #include "microros.h"

  extern int absoluteUsedMemory;
  extern int usedMemory;


  void * __freertos_allocate(size_t size, void * state);
  void __freertos_deallocate(void * pointer, void * state);
  void * __freertos_reallocate(void * pointer, size_t size, void * state);
  void * __freertos_zero_allocate(size_t number_of_elements,
  size_t size_of_element, void * state);

  #endif // _ALLOCATORS_H_
#+END_SRC

* Footnotes

[fn:6] The name of the installer binary file might change as a new version of the IDE
is release every year or so.

[fn:5] The overlapping memory will not prevent the board to boot,
but it disables the PWM for the CPU fan, which will then run at full speed, making noise. 

[fn:4] A [[https://zenn.dev/ryuz88/articles/kv260_setup_memo_ubuntu22 ][blog post]] (JP) shows all major steps on how to enable the ~remoteproc~.

[fn:3] A [[https://speakerdeck.com/fixstars/fpga-seminar-12-fixstars-corporation-20220727][slideshow]] (JP) from Fixstar employees presents how to use the device
  tree to enable the communication between the cores.

[fn:2] The ~snap~ package depends on each other. Thus dependencies
cannot be remove before the package(s) that depends on them.

[fn:1] Again, it is critical to be 100\% certain that you are working with
the correct device! 
