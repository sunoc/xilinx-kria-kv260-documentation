:PROPERTIES:
:ID:       ac338634-949e-4e3a-8d75-45bed92243c6
:CATEGORY: KRIA
:END:
#+title: Setting up and using
#+title: Xilinx KRIA KV260 and KR260
#+filetags: :export:
#+subtitle: \begin{CJK}{UTF8}{min}南山大学\end{CJK}
#+author: Vincent Conus
#+email: vincent.conus@protonmail.com
#+date: 2023-12-22

* Headers and LaTeX settings for export                            :noexport:
A large amount of headers and parameters are needed in order
to have this "README" document being exportable as a LaTeX
document formatted the way I wanted it to be.

The detail can be seen in the raw ~.org~ version of this README
and stays hidden in a :noexport: section in this report.

#+DESCRIPTION: A report presenting how to use and set Xilinx's Kria board
#+LANGUAGE: English

#+OPTIONS: H:3 toc:t date:t title:t email:t

#+LATEX_COMPILER:

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:[10pt]
#+LATEX_HEADER: \usepackage[a4paper, total={6.5in, 9in}]{geometry}

#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{breaklines}
#+LATEX_HEADER: \usepackage[AUTO]{inputenc}
#+LATEX_HEADER: \renewcommand{\familydefault}{\sfdefault}
#+LATEX_HEADER: \usemintedstyle{vs}

#+LATEX_HEADER: \usepackage[most]{tcolorbox}

#+LATEX_HEADER: \usepackage{CJKutf8}
#+LATEX_HEADER: \usepackage{xurl}
#+LATEX_HEADER: \usepackage{fontawesome5}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{float}

#+LATEX_HEADER: \newcommand{\gitlab}[1]{%
#+LATEX_HEADER:    \href{#1}{GitLab \faGitlab}}

#+begin_src emacs-lisp :exports results :results none :eval export
(make-variable-buffer-local 'org-latex-title-command)
(setq org-latex-title-command (concat
			       "\\begin{titlepage}\n"
			       "\\centering\n"
			       "{\\LARGE %t \\par }\n"
			       "\\vspace{5mm}\n"
			       "{\\large %s \\par}\n"
			       "\\vspace{1cm}\n"
			       "{\\large %D \\par}\n"
			       "\\vspace{2cm}\n"
			       "{\\large %a -  Source available at \\gitlab{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation} \\par}\n"
			       "\\vspace{3cm}\n"
			       "\\includegraphics[width=0.8\\textwidth]{./img/boards}"
			       "\\end{titlepage}\n"))
#+end_src

#+begin_src emacs-lisp :exports results :results none :eval export
(make-variable-buffer-local 'org-latex-toc-command)
(setq org-latex-toc-command (concat
			     "\\tableofcontents\n"
			     "\\pagebreak\n"))
#+end_src

* Integration in my org-roam system                                   :noexport:
#+BEGIN_SRC sh
ln -fs $PWD/README.org ~/Nextcloud/zettel/Xilinx_KRIA_KV260.org # org-roam
ln -fs $PWD/README.org ~/Nextcloud/todo/xilinx_kria.org # org-agenda
#+END_SRC

#+RESULTS:

* Building this report from the LaTeX file                         :noexport:
The base file for this report is actually this README.org file itself.
However, upon local build, this file is regularly exported as
a ~.tex~ file that can be built normally.
On a moderately recent Ubuntu-base distribution, the following packages seemed to be required to build the
report:

#+BEGIN_SRC bash
sudo apt-get install texlive-base texlive-latex-recommended texlive-lang-japanese
#+END_SRC

Then, the actual build can be made with a simple:

#+BEGIN_SRC bash
pdflatex README.tex
#+END_SRC

* Introduction & motivation
This guide will present how to setup and use Xilinx's KRIA board, in particular
for running ROS on a host Ubuntu system, as well as for deploying
micro-ROS[[cite:&Belsare2023]] as a firmware on the MCU part of this board's chip.

The use of this device in particular is interesting because of the presence of a
CPU comprising both a general purpose ARM core, capable of running a Linux
distribution, as well as another ARM core, real-time enabled, capable to run a
RTOS. The figure [[fig:map]] below shows a schematic view of the overall system we
are trying to archive.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The Linux and ROS2 environment (orange) will
#+CAPTION: communicate with the real-time, FreeRTOS and micro-ROS
#+CAPTION: side (blue) using RPMsg (shared memory).
#+NAME: fig:map
[[file:img/map.png]]

* Boot firmware
#+INCLUDE: "./boot_firmware.org" :minlevel 2 :lines "6-"
** COMMENT LINK: [[id:be2ce0ab-07db-49e6-be50-72f2db76cde3][KRIA board boot firmware update]]

* Installing Ubuntu LTS 22.04
#+INCLUDE: "./install_ubuntu.org" :minlevel 2 :lines "34-469"
** COMMENT LINK: [[id:582fe4ef-a301-4b53-b908-a5c2b5b6d694][KRIA board Ubuntu LTS 22.04 Install]]


#+LATEX: \pagebreak
* Setting up a Vitis IDE project
#+INCLUDE: "./vitis_ide.org" :minlevel 2 :lines "34-"
** COMMENT LINK: [[id:dfc7e5d2-fe7b-432e-8dcc-e1227929fc62][KRIA board Vitis IDE setup]]

* DONE R5F firmware without an IDE
CLOSED: [2024-02-13 火 15:28] SCHEDULED: <2024-02-13 火 13:00>

- State "DONE"       from "TODO"       [2024-02-13 火 15:28]
The Section [[Setting up a Vitis IDE project]] was merely a presentation on how
bootstrap a brand new development project using Xilinx provided templates in their crap IDE.

Once the project exist, one can simply compile it again using the generated ~Makefile~.

The information on how to handle the project are available directly in the
repository of said project[fn:1] and it's various branches for ongoing feature
development.


#+LATEX: \pagebreak
* RPMsg ~echo_test~ software
In order to test the deployment of the firmware on the R5F side, and in particular
to test the RPMsg function, we need some program on the Linux side of the Kria
board to "talk" with the real-time side.

Some source is provided by Xilinx to build a demonstration software that does
this purpose: specifically interact with the demonstration firmware.

Here are the steps required to obtain the sources, and build the program.

As a reminder, this is meant to be done on the Linux running on the
Kria board, NOT on your host machine !

#+BEGIN_SRC sh
git clone https://github.com/Xilinx/meta-openamp.git
cd  meta-openamp
git checkout xlnx-rel-v2022.2
cd  ./recipes-openamp/rpmsg-examples/rpmsg-echo-test
make
sudo ln -s $(pwd)/echo_test /usr/bin/
#+END_SRC

Once this is done, it it possible to run the test program from the Kria board's Ubuntu
by running the ~echo_test~ command.

* Building micro-ROS as a static library
In this section, the goal is to build the micro-ROS library in order to be
able to integrate it's functions into our Cortex R5F firmware.

All of this should be done via cross-compiling on a host machine, however
it is most common in the guides about micro-ROS to build the firmware and libraries within a Docker,
so we can have access of the ROS environment without installing it permanently.

One can simply run this command to summon a ROS2 Docker[fn:8] with the wanted version,
but first we also need to check the cross-compilation tools.

We are downloading the latest ~arm-none-eabi~ gcc compiler directly from the ARM website.

The cross-compilation tool can then be extracted, set as our ~toolchain~ variable,
then passed as a parameter when creating the Docker container:
#+BEGIN_SRC sh
pushd /home/$USER/Downloads
wget https://developer.arm.com/-/media/Files/downloads/gnu/13.2.rel1/binrel/arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz
tar -xvf arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz
popd

toolchain="/home/$USER/Downloads/arm-gnu-toolchain-13.2.Rel1-x86_64-arm-none-eabi/"


docker run -d --name ros_build -it --net=host \
       --hostname ros_build \
       -v /dev:/dev \
       -v $toolchain:/armr5-toolchain \
       --privileged ros:iron
#+END_SRC

Now the container named ~ros_build~ was created, it is possible to "enter" it, and having access
to the tools in it by running the following command that will open a ~bash~ shell in said container:
#+BEGIN_SRC sh
docker exec -it ros_build bash
#+END_SRC

Now we are in the ROS2 container, we can build the micro-ROS firmware as presented
in the [[https://micro.ros.org/docs/tutorials/advanced/create\_custom\_static\_library][dedicated micro-ROS guide]]:
#+BEGIN_SRC sh
echo 127.0.0.1 $HOSTNAME >> /etc/hosts
sudo apt update 
sudo apt-get -y install python3-pip \
     wget \
     nano

. /opt/ros/$ROS_DISTRO/setup.bash

mkdir microros_ws
cd microros_ws
git clone -b $ROS_DISTRO \
    https://github.com/micro-ROS/micro_ros_setup.git \
    src/micro_ros_setup

sudo rosdep fix-permissions &&\
    rosdep update &&\
    rosdep install --from-paths src --ignore-src -y

colcon build
. ./install/local_setup.bash

ros2 run micro_ros_setup create_firmware_ws.sh generate_lib
#+END_SRC


From that point, we will need some extra configuration files for our Cortex R5F.

Both configuration files[fn:9] will be downloaded from my repository;
we also are going to copy the cross-compiler into the microros workspace,
then we can build the library with the following ros2 command:
#+BEGIN_SRC sh
wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/raw/main/src/custom_r5f_toolchain.cmake

wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/raw/main/src/custom_r5f_colcon.meta

cp -r /armr5-toolchain/ $(pwd)/firmware/toolchain && \
    export PATH=$PATH:$(pwd)/firmware/toolchain/bin

ros2 run micro_ros_setup build_firmware.sh \
     $(pwd)/custom_r5f_toolchain.cmake \
     $(pwd)/custom_r5f_colcon.meta
#+END_SRC
#+LATEX: \pagebreak

* Including micro-ROS to the real-time firmware
Now we have a Vitis demonstration project available and the ~libmicroros~ static library
available, we can combine both by including this library into our Kria project.

On the host machine running the IDE, we can download the static library
and the include files from the Docker builder.
Here, we assume your Vitis IDE workspace sits in you home directory, at ~~/workspace~,
and that the Docker container is named ~ros_build~:
#+BEGIN_SRC sh
mkdir /home/$USER/workspace/microros_lib

docker cp ros_build:/microros_ws/firmware/build/\
       libmicroros.a /home/$USER/workspace/microros_lib/

docker cp ros_build:/microros_ws/firmware/build/include \
       /home/$USER/workspace/microros_lib/
#+END_SRC

Many parameters are available to be set up in the IDE for the compilation tool-chain, but
the figures [[fig:include]] and [[fig:include2]] below will show you a setup that worked to have the IDE
to recognize the include files and to be able to use them for compiling the firmware.

#+ATTR_LATEX: :width .8\textwidth
#+CAPTION: Firstly, in the "C/C++ Build" settings of your firmware project,
#+CAPTION: under the "Settings" menu, you should find the gcc compiler "Directories".
#+CAPTION: In here you should add the "include" directory of your library.
#+CAPTION: Be careful however, if your include files are in a second layer of directory
#+CAPTION: (as it is the case for libmicroros) you will need to include each sub-directory individually,
#+CAPTION: as visible in this figure.
#+NAME: fig:include
[[file:./img/vitis_new/include.png]]

#+ATTR_LATEX: :width .8\textwidth
#+CAPTION: Secondly, in the gcc linker "Libraries", you can add the top level directory of your library.
#+CAPTION: In our case, it is the directory that contains both the "include" directory added earlier,
#+CAPTION: and also the "libmicroros.a" file.
#+NAME: fig:include2
[[file:./img/vitis_new/include2.png]]

#+LATEX: \pagebreak
With both of these setup in your project and as a minimal test to see if the setup was made correctly,
you should be able to include the following micro-ROS libraries into your project:
#+BEGIN_SRC C
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#+END_SRC

The details for the inclusions and the use-case of the library will depend on the implementation
of the firmware itself.

But in general, as the firmware is successfully built and an ~.elf~ file is available and can be uploaded as a
firmware to the Kria board (or any remote server accessible through ~SSH~, for that matter) with the following
command[fn:10]:
#+BEGIN_SRC sh
scp /home/sunoc/workspace/rpmsg_pingpong_microros_lib/\
    Debug/rpmsg_pingpong_microros_lib.elf  ubuntu@192.168.1.10:/home/ubuntu/
#+END_SRC
#+LATEX: \pagebreak

* micro-ROS adaptation for the firmware
Beyond the inclusion of the library itself, actually using the micro-ROS system
within an external project require more than just importing the needed
functions.

Indeed, if you would be just adding the various function for sending messages to
the general ROS2 network, you would face issues with four key aspects.
These are presented in the following dedicated sub-sections.

** Time functions
As micro-ROS can be used on a variety of board, it does not understand by itself
what time functions are meant to be used.

In that regard, some API-style function are being
used in the library and it is then needed for the person using a new board
to implement these function inner working using the board own time-related
function calls.

In particular for this part, the ~clock_gettime~ function is key, and could
simply be implemented with some FreeRTOS time functions.

The end result for these implementation are visible in the appendix [[Firmware time functions]],
and can be reused as-if for the Kria board setups.

** Memory allocators
Similarly to the time function, it is required to re-implement some form of memory allocating
functions in order for the library to be able to work with such functions in a formalized way.

As for now, the current version of the allocator function can be seen in the
appendix [[Firmware memory allocation functions]], but the current setup is not
completely "clean", some further formatting, test and modification will be needed.

** Custom transport layer
This part is the key translation layer that needs to happen in order for the
DDS system from the micro-ROS library to be using the communication channel we
want it to.

A problem that had to be figured out lives in the fact that the operation of micro-ROS DDS
and the board's RPMsg communication system does not operate in the same fashion.

The former expects to have four functions ("open", "read", "write" and "close") that can
be called and used by the main system, while the latter relies on FreeRTOS callback
system, waiting on the service interrupt routine to be trigger by an incoming message.

This situation meant that we count not simple translate the communication layers from one
to another: a non-blocking polling and buffer system needed to be put into places.
The proposed solution that was implemented and that is currently being tested
is showed and detailed in the figure [[fig:rpmsg_fw_tasks]] below.

The next figure [[fig:client_arch]] show a more visual representation of the two tasks and the
functions used in them.

#+ATTR_LATEX: :width .9\textwidth
#+CAPTION: Two tasks are being run concurrently in order to manage the
#+CAPTION: communication situation, with binary semaphore-based lock-unlock system.\\
#+CAPTION: The role of the micro-ROS task (red) is to make the four functions
#+CAPTION: ("open", "read", "write" and "close")  available and running the actual
#+CAPTION: software function. In this example, polling the read function and writing
#+CAPTION: back when something is receive (ping-pong function).
#+CAPTION: The use of the ~rpmsg_send()~ function is done directly from the micro-ROS task,
#+CAPTION: bypassing the RPMsg task in this situation.\\
#+CAPTION: In the libmicroros implementation currently being developed, the micro-ROS task
#+CAPTION: holds all the DDS and micro-ROS system, including the mentioned allocators function.\\
#+CAPTION: The RPMsg task (green) is used to firstly set the RPMsg communication
#+CAPTION: with the Linux system, then it stays locked until the ISR (interrupt service routine)
#+CAPTION: is triggered by an incoming message. The message is then passed to the micro-ROS
#+CAPTION: task using a buffer.\\
#+CAPTION: When a shutdown signal is received from the Linux, both functions will gracefully close
#+CAPTION: and are getting killed.
#+NAME: fig:rpmsg_fw_tasks
[[file:./img/tasks.png]]

#+ATTR_LATEX: :width .9\textwidth
#+CAPTION: Functions architecture for the Client firmware.
#+NAME: fig:client_arch
[[file:./img/client_arch.png]]

A version of this firmware is available at my gitlab repository[fn:20]. This firmware was built using
Xilinx's IDE, which setup was presented in the section [[Setting up the IDE]], however it was tested
and given the provided ~Makefile~ system, it is possible to modify and rebuild the firmware
without this specific tools, as long as the compiler is installed correctly.

Beyond the general two-tasks behavior of the figure [[fig:rpmsg_fw_tasks]], here are the main steps
of the execution of the firmware:
+ During the RPMsg init phase (RPMsg task), a "hello" message is exchanged with the Linux side
  to confirm the OpenAMP system is also ready there.
+ Memory allocations and custom transport function are set in the micro-ROS task.
+ The micro-ROS and it's ~rclc~ system run extensive initialization tasks to:
  - Initialize the support system
  - Initialize the support node
  - Initialize the publishers
  - Initialize the subscribers
+ Finally, the ping-pong function become effective with the micro-ROS task
  polling to receive some message and sending it back to the sender.

** Building the updated firmware outside of the IDE       :WORK_IN_PROGRESS:
While the use of the IDE presented in the previous sections is much needed in order to first create
a RPMsg-ready base firmware, it might be inconvenient having to carry this extremely heavy tool
for any modification or rebuild of the firmware.

Fortunately, the Vitis IDE projects have a very handy function: they general a pure ~Makefile~, with
all the needed dependencies and path for library set.
This ~make~ system can be used externally, however, and as explained previously, two conditions must be
fulfilled:
+ The cross-compiler needs to be in the ~$PATH~.
+ Standard building tools must be installer, in particular ~git~ in order to obtain the repository,
  and ~make~, obviously.

#+BEGIN_SRC sh
cd /tmp
git clone https://gitlab.com/sunoc/libmicroros_kv260.git
cd libmicroros_kv260/Debug
make
#+END_SRC

From there, you will have the binary ~rpmsg_pingpong_microros_lib.elf~ file created and ready to be deployed
on the KRIA board.

** Improvement to be made
While the version of the firmware since the tag ~0.1~[fn:23] are functional, able to communicate with
an Agent placed on the neighbour Linux, some work, improvements and tweaks are still to be made.

*** WAIT [#A] Firmware stop / crash / reboot
maybe a complete re-implementation with a different os / else
would be better.
This is maybe the most annoying issue that is currently still ongoing: if the firmware
is not stopped in a "clean" way, the RPMsg task is not kill, making a full reboot of the board
needed in order to re-launch the firmware and having an established communication.

Something need to be done about that.

#+LATEX: \pagebreak
* Loading the firmware
Having a version of our ~.elf~ firmware (with or without the included
micro-ROS library) built and loaded onto our Kria's Linux, we want to load and run it
on the Cortex micro-controller side.

As a reminder, the firmware can be loaded from the host machine IDE workspace
to the Kria board through ~SSH~ using the following command:
#+BEGIN_SRC sh
scp /home/sunoc/workspace/rpmsg_pingpong_microros_lib/\
    Debug/rpmsg_pingpong_microros_lib.elf  ubuntu@192.168.1.10:/home/ubuntu/
#+END_SRC

The following instructions will show how to use this binary file, and
in particular how to upload and start the firmware on the R5F real time core
from the Linux user-space[fn:11], to test a basic RPMsg setup[fn:12]:
#+BEGIN_SRC sh
sudo -s
mv image_echo_test /lib/firmware
echo image_echo_test  > /sys/class/remoteproc/\
     remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
#+END_SRC

In this setup you need to be careful for the name of the ~.elf~ binary to be exactly used
in the first ~mv~ and ~echo~ command. In this example, the binary would be named
~image_echo_test.elf~, and moved from ~$HOME~ to ~/lib/firmware~.

The debug of the firmware itself is done by reading the "printf" visible from the serial
return of the board (typically a ~/dev/ttyUSB1~), but two things are to be noted:
+ If the ~echo start~ command fails, either the previous firmware run was not stopped,
  or the new binary itself is impossible to run.
+ In general, if the ~echo_test~ runs, it means that everything is okay and that
  the RPMsg system worked successfully.
#+LATEX: \pagebreak

* Running a ROS2 node
This section as well as the next one are rather "separated" from the rest of the report, as
they are focused on the ROS2 system being used on the Kria board.

In this first section, the installation of ROS2 as a system will be presented, with
two different ways of approaching the problem.

As for the previous section, the figure [[fig:map_ros]] below shows what part
of the overall system we are talking about here.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The ROS2 middle (red border) runs on top of the Linux,
#+CAPTION: on the general-purpose core of the Kria board.
#+NAME: fig:map_ros
[[file:./img/map_ros.png]]

#+ATTR_LATEX: :width .55\textwidth
#+CAPTION: Methods architecture for the modified Agent node.
#+NAME: fig:agent_arch
[[file:./img/agent_arch.png]]

** On the host Linux ("bare-metal")
Since an Ubuntu distribution is installed on the board, the installation of ROS2
can be done[fn:13] in a standard way, using the repository.

An [[https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html][official documentation]] is provided with ROS2 themselves with a step-by-step guide on how to install
ROS2 on a Ubuntu system{}.
We will be following this guide here[fn:14].

Firstly, we need to update the locals, enable the universe Ubuntu repository,
get the key and add the repository for ROS2. This can be done as follow:
#+BEGIN_SRC sh
locale  # check for UTF-8
sudo apt update && sudo apt install -y locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
locale  # verify settings

sudo apt install -y software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install -y curl wget

wget https://raw.githubusercontent.com/ros/rosdistro/master/ros.key
sudo mv ros.key /usr/share/keyrings/ros-archive-keyring.gpg
#+END_SRC

Then, a thicc one-liner is available to add the ROS2 repository to our system:
#+BEGIN_SRC sh
echo "deb [arch=$(dpkg --print-architecture) \
signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] \
http://packages.ros.org/ros2/ubuntu $(. \
/etc/os-release && echo $UBUNTU_CODENAME) main" | \
    sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
#+END_SRC

It is then possible to install ROS2[fn:15] as follow:
#+BEGIN_SRC sh
sudo apt update
sudo apt upgrade -y
sudo apt install -y ros-$ROS_DISTRO-desktop \
     ros-$ROS_DISTRO-ros-base \
     python3-argcomplete \
     ros-dev-tools
#+END_SRC

Once installed, it is possible to test the system with a provided example.
You need to open two terminals and log wish SSH onto the board, then running
respectively:
#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash
ros2 run demo_nodes_cpp talker
#+END_SRC

And then:
#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash
ros2 run demo_nodes_py listener
#+END_SRC

You should be able to see the first terminal sending "Hello world" messages,
and the second one receiving then.

** In a container (Docker)
As containers are used to test and build micro-ROS configurations,
running ROS2 in a Docker  is a great way to have a reproducible configuration
of you system.

This part of the guide will present how to install Docker on the
Kria board and then how to use it to deploy the latest version of ROS2.
This section of the report assumes that Docker was installer on the target system
as presented in section [[Installing Docker]].

The following commands will pull a ROS container, version ~iron~, and name it ~ros_build~.

A key part for having access to the interfaces (serial) is the mapping of the whole ~/dev~
range of devices from the host machine to the internal ~/dev~ of the container[fn:16].
With the second command, we can execute ~bash~ as a way to open a terminal to the "inside" the container:
#+BEGIN_SRC sh
docker run -d --name ros_agent -it --net=host -v \
       /dev:/dev --privileged ros:iron
docker exec -it ros_agent bash
#+END_SRC

From there, it becomes possible to simply use ROS2 as you would for a bare-metal install,
and as presented in the section [[On the host Linux ("bare-metal")]] above:
#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash

# Create a workspace and download the micro-ROS tools
mkdir microros_ws
cd microros_ws
git clone -b $ROS_DISTRO https://github.com/micro-ROS/\
    micro_ros_setup.git src/micro_ros_setup

# Update dependencies using rosdep
sudo apt update && rosdep update
rosdep install --from-paths src --ignore-src -y

# Install pip
sudo apt-get install python3-pip

# Build micro-ROS tools and source them
colcon build

# Download micro-ROS-Agent packages
source install/local_setup.bash
ros2 run micro_ros_setup create_agent_ws.sh

# Build step
ros2 run micro_ros_setup build_agent.sh

# Run a micro-ROS agent
ros2 run micro_ros_agent micro_ros_agent serial \
     --dev /dev/ttyUSB1
#+END_SRC

Then once again in a similar way to the bare-metal deployment,  it is possible to run a demonstration
the ping-pong topic communication from a different shell[fn:17]:
#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash

# Subscribe to micro-ROS ping topic
ros2 topic echo /microROS/ping
#+END_SRC
#+LATEX: \pagebreak

* micro-ROS XRCE-DDS Agent
The micro-ROS Agent on the ROS2 side is the last piece of the puzzle needed to
allow our DDS environment to use RPMsg as a mean of communication, as visible
on the schematic of the figure [[fig:map_agent]] below.
In particular, it will be useful to modify this agent in order to archive
the full RPMsg communication for ROS2[fn:19].
An [[https://micro.ros.org/docs/tutorials/advanced/create_custom_transports/][official documentation]] exists, but it gives little to no detail
on how to deploy such modified, custom transport setup.
This part of the guide will focus on it.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: The agent (red border) allows for a micro-ROS
#+CAPTION: instance to communicate with a ROS2 system.
#+CAPTION: It is deployed on the Linux side, as a ROS2 node.
#+NAME: fig:map_agent
[[file:./img/map_agent.png]]

** [irrelevant] Building a eProsima bare-metal example agent
A key aspect to understand about modifying the agent (as
this will be needed later on to support our new communication system),
is that the default system and instruction provided by micro-ROS does not
allow such modification[fn:18].

In order to avoid that, one can get and run a ROS2 node design by eProsima,
that can be deployed on it's own (without other ROS2 application and nodes)
and eventually modified.


#+BEGIN_SRC sh
sudo nano /microros_ws/build/micro_ros_agent/agent/src/xrceagent/src/cpp/transport/custom/CustomAgent.cpp
#+END_SRC
The same file is available online as a reference, on eProsima repository[fn:27].

#+BEGIN_SRC sh
git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
cd Micro-XRCE-DDS-Agent/

rm -rf examples/
git clone https://gitlab.com/sunoc/rpmsg-micro-ros-agent.git ./examples/custom_agent

mkdir build && cd build
cmake -DUAGENT_BUILD_USAGE_EXAMPLES=ON ..
make
#+END_SRC

The custom agent is then available to run from the ~./src/examples/custom_agent/CustomXRCEAgent~.

All the diff when the custom agent system was added:
https://github.com/eProsima/Micro-XRCE-DDS-Agent/pull/205/files

For rebuilding the custom agent with a simple ~make clean && make all~ will
conveniently only rebuild the part that was modify.
Which means that once all the libraries have been compiled once,
the subsequent re-compilation of the agent itself can be done quickly !

Major details on how to implement a custom agent specified here:
https://github.com/eProsima/Micro-XRCE-DDS-Agent/issues/195#issuecomment-721002153

# Running the custom agent executable can be executed as is as the transport we want to use is already
# built in. ~kmod~ package is needed though.
# #+BEGIN_SRC sh
#   sudo apt-get update
#   sudo apt-get install kmod
#     ./examples/custom_agent/CustomXRCEAgent
# #+END_SRC

** Building a XRCE-DDS agent in a Docker
The same command presented above for running a custom agent "bare-metal" can be
run inside a Docker.

#+BEGIN_SRC sh
docker run -d --name XRCE_DDS_Agent -it --net=host -v \
       /dev:/dev --privileged ros:iron
docker exec -it XRCE_DDS_Agent bash
#+END_SRC


#+BEGIN_SRC sh
git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
cd Micro-XRCE-DDS-Agent
docker build -t xrce-dds-agent .
docker run -it --privileged -v /dev:/dev xrce-dds-agent serial \
       --dev /dev/ttyACM0
#+END_SRC

** Building the Agent version with a modified transport
The first working implementation of the DDS over RPMsg happened over a
XRCE-DDS agent whose ~serial~ transport layer has been modified in order
to use OpenAMP's RPMsg instead.

The build process it the same as usual, just pulling from my fork of eProsima repository
and using the ~develop~ branch:

#+BEGIN_SRC sh
git clone https://github.com/sunoc/Micro-XRCE-DDS-Agent.git -b develop
cd Micro-XRCE-DDS-Agent
mkdir build
cd build
cmake ..
make
#+END_SRC

Giving that your are working from an environment in which the ROS2 tools are available, it is then possible
to run the Agent as follow[fn:21] [fn:22]:

#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash

./MicroXRCEAgent serial --dev /dev/null --verbose 6
#+END_SRC

** WAIT [#C] Separated RPMsg transport created for XRCE-DDS Agent
now focusing on updating my knowledge about the techo.
gotta update the doc latec
- [ ] Implementation done
- [ ] Successfully tested
- [ ] Pull request done to the eProsima repository

** Creating a custom transport agent                      :WORK_IN_PROGRESS:
These command allows to go build the agent and run it with maximum verbosity (for debugging purpose).
#+BEGIN_SRC sh
source /opt/ros/$ROS_DISTRO/setup.bash
cd /Micro-XRCE-DDS-Agent/build
make clean && make -j4
./MicroXRCEAgent serial --dev /dev/null --verbose 6
#+END_SRC


#+LATEX: \pagebreak

* Running the ping-pong node                               :WORK_IN_PROGRESS:
A custom ping-pong node for ROS2 was developed in order to test the data transfer of the newly created
Agent / Client system.

In order to have this node up and running, you need to set basically all the previously presented points:
- The micro-ROS firmware is running on the R5F core, as presented in the section [[Loading the firmware]].
- On the same Linux you plan to run the node, you will need to run and keep the Agent, as presented
  in the section [[micro-ROS XRCE-DDS Agent]].
- This ping-pong application is released as a ROS2 Python node. It is best to pull and run it
  in a ROS2 environment to avoid having dependencies issues, as presented in the section [[Running a ROS2 node]].

* Monitoring and performances evaluation                   :WORK_IN_PROGRESS:

* Conclusion & future                                      :WORK_IN_PROGRESS:

#+LATEX: \pagebreak
#+LATEX: \appendix
* DTO patch
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch][system.patch]]
#+LATEX: \inputminted[linenos, frame=single]{diff}{./src/system.patch}

#+LATEX: \pagebreak
* Custom tool-chain CMake settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_toolchain.cmake][custom r5f toolchain.cmake]]
#+LATEX: \inputminted[linenos, frame=single]{cmake}{./src/custom_r5f_toolchain.cmake}

#+LATEX: \pagebreak
* Custom Colcon meta settings
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom_r5f_colcon.meta][custom r5f colcon.meta]]
#+LATEX: \inputminted[linenos, frame=single]{yaml}{./src/custom_r5f_colcon.meta}

#+LATEX: \pagebreak
* Firmware time functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/clock.c][clock.c]]
but a potentially more up-to-date version is visible
directly at the ~libmicroros_kv260~ repository: [[https://gitlab.com/sunoc/libmicroros_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/clock.c][clock.c]]

#+LATEX: \inputminted[linenos, frame=single]{c}{./src/clock.c}

** header file
#+BEGIN_SRC C
/**< Microseconds per second. */
#define MICROSECONDS_PER_SECOND    ( 1000000LL )  
/**< Nanoseconds per second. */
#define NANOSECONDS_PER_SECOND     ( 1000000000LL ) 
/**< Nanoseconds per FreeRTOS tick. */  
#define NANOSECONDS_PER_TICK       ( NANOSECONDS_PER_SECOND / configTICK_RATE_HZ ) 
#+END_SRC


#+LATEX: \pagebreak
* Firmware memory allocation functions

** main
This file is available in this repository: [[https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/allocators.c][allocators.c]]
but a potentially more up-to-date version is visible
directly at the ~libmicroros_kv260~ repository: [[https://gitlab.com/sunoc/libmicroros_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/allocators.c][allocators.c]]

#+LATEX: \inputminted[linenos, frame=single]{c}{./src/allocators.c}

** header file
#+BEGIN_SRC C
#ifndef _ALLOCATORS_H_
#define _ALLOCATORS_H_

#include "microros.h"

extern int absoluteUsedMemory;
extern int usedMemory;


void * __freertos_allocate(size_t size, void * state);
void __freertos_deallocate(void * pointer, void * state);
void * __freertos_reallocate(void * pointer, size_t size, void * state);
void * __freertos_zero_allocate(size_t number_of_elements,
				size_t size_of_element, void * state);

#endif // _ALLOCATORS_H_
#+END_SRC
* [deprecated] Installing Linux (PetaLinux option)
This part is an alternative to the previous section [[Installing Ubuntu LTS 22.04]],
where the installation of PetaLinux as a host system[fn:24] will be presented,
as being an alternative to the Ubuntu LTS. Here are some reasoning why you'd
prefer to use PetaLinux instead of Ubuntu:
+ Direct support from Xilinx. While Ubuntu is also an official port, it is
  provided through Canonical.
+ If you plan to use ROS2 in containers.

It is also to be noted that the building process of a PetaLinux image is not as
trivial as simply flashing a downloaded ISO file. It takes some time to
configure it and even more time to be built, especially if you are working on a
lower-end machine.

** General installation
The indication on how to install PetaLinux on a KRIA board is detailed in the
official documentation[fn:25], but for the KV260 board with an older release of
the Linux. This guide will try to keep an up-to-date version of the guide, in
particular for the KR260 KRIA board and, at the time of writing, the PetaLinux
in version 2023.2 for the installer.  The 2022.2 version is recommended for this
board's latest updated boot firmware, as presented in the Section [[Boot firmware]]
above; however I happened to have issues with the building process from a system
based on Ubuntu 22.04. Thus the choice of the 2023.2 that should be compatible.

Two tools should be downloaded upfront in order to be ready and create the
PetaLinux image for our target board. Both can be obtained at the Xilinx
official download page[fn:26]. Login with an AMD account is required in order to
download the files we need, namely, we'll have to get:
+ The installer tool: ~petalinux-v2023.2-10121855-installer.run~ or similar name.
+ The SOM board support package: ~xilinx-kr260-starterkit-v2023.2-10140544.bsp~ or similar name[fn:29].
The specific name of the utils you'll get to download will evolve over time.

For the following command, I will assume that both files were downloaded into
the same directory and that you have a shell open in said directory.

Firstly, a crap ton of dependencies are needed. They are detailed in the
release notes of the version of the tool you are downloading and it depends on
your distribution, but here is a one-liner that works for the PetaLinux 2023.2
to be built on Ubuntu(-based) 22.04 LTS:
#+BEGIN_SRC sh
sudo apt-get install iproute2 gawk python3 build-essential gcc git make \
     net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 \
     gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip \
     texinfo zlib1g-dev gcc-multilib automake zlib1g:i386 screen pax gzip cpio \
     python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git \
     python3-jinja2 libegl1-mesa libsdl1.2-dev pylint asciidoc
#+END_SRC

Installing the petalinux tools can be done with the ~.run~ script[fn:28], as follow:
#+BEGIN_SRC sh
sudo chmod +x ./petalinux-v2023.2-10121855-installer.run
./petalinux-v2023.2-10121855-installer.run
bash
source settings.sh
#+END_SRC

A project can then be created, using the ~.bsp~ file. From there it is possible to
build the image file meant to be booted by the board:
#+BEGIN_SRC sh
petalinux-create -t project -s xilinx-kr260-starterkit-v2023.2-10140544.bsp
cd xilinx-kr260-starterkit-2023.2/
#+END_SRC


The more general option allows to enable stuff related to hardware
configuration[fn:33]. For this step, it is possible to select the ~openamp~
setting the the DTG Settings, as visible in the Figure [[fig:yocto_openamp_dtg]] below:
#+BEGIN_SRC sh
petalinux-config --get-hw-description  ./hardware/xilinx-kr260-starterkit-2023.2/kr260_starter_kit.xsa
#+END_SRC

Then, here are the options that we want to enable:
#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In the hardware config, it is possible to select the openamp device tree source.
#+NAME: fig:yocto_openamp_dtg
[[file:./img/yocto_openamp_dtg.png]]

Some kernel and module configuration are needed in order for the petalinux system to work properly.
These setup can be set using the following command:
#+BEGIN_SRC sh
petalinux-config -c rootfs
#+END_SRC

Then, here are the options that we want to enable:
#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: In the rootfs config, it is possible to select the openamp package.
#+NAME: fig:yocto_openamp
[[file:./img/yocto_openamp.png]]


#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: OpenSSH can be configure in the same rootfs config.
#+NAME: fig:yocto_ssh
[[file:./img/yocto_ssh.png]]

It is then possible to build[fn:32] and package the image. Most critically compared to the example,
the ~openamp.dtb~ overlay must be used in order for OpenAMP and subsequently RPMsg to become usable.
#+BEGIN_SRC sh
petalinux-build
petalinux-package --wic --bootfiles "ramdisk.cpio.gz.u-boot boot.scr Image system.dtb"
#+END_SRC

#+LATEX: \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
*DANGER*: The next part involve the ~dd~ command writing on disks!!!
As always with the dd command, thou have to be *VERY* careful on what arguments
thou give. Selecting the wrong disk will result on the destruction of
thy data !!
_If you are unsure of what to do, seek assistance !_
#+LATEX: \end{tcolorbox}

Finally, and now an image has been generated, it can be burnt to a micro-SD card the usual way:
#+BEGIN_SRC sh
sudo dd if=./images/linux/petalinux-sdimage.wic \
     of=/dev/sda status=progress bs=8M && sync
#+END_SRC

From that point, the media can be ejected, put in the board and the boot process
should happen successfully.

** Testing openamp "echo-test"
A good and out-of-the-box way to try and confirm that the OpenAMP setup was done
properly is to run the so-called "echo-test". This program will basically send
series of packages to the R5F core and expect them to be returned.

As presented in the official documentation[fn:34], this can be simply done with
the following commands. If the return of the ~echo_test~ commands states that zero
error occurs, the system should be good to go:
#+BEGIN_SRC sh
sudo -s
echo image_echo_test  > /sys/class/remoteproc/remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
#+END_SRC

** "echo-test" performance comparison

*** Raw plot of the package measurement                          :noexport:
#+BEGIN_SRC python :results file :eval no-export
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats

df_kr = pd.read_csv('./csv/kr260_echo_test.csv', names=['time KR260 (PetaLinux)'])
df_kv = pd.read_csv('./csv/kv260_echo_test.csv', names=['time KV260 (Ubuntu)'])

df_payload = pd.DataFrame([s] for l in range(0, 10, 1) for s in range(17, 489, 1))

df_tot_2 = pd.concat([df_kr, df_kv, df_payload], sort=False, axis=1)

df_tot_2 = df_tot_2.rename(columns={0:'Payload size'})

df_tot_2['time KR260 (PetaLinux)'] = df_tot_2['time KR260 (PetaLinux)'].div(df_tot_2['Payload size'])
df_tot_2['time KV260 (Ubuntu)'] = df_tot_2['time KV260 (Ubuntu)'].div(df_tot_2['Payload size'])

df_tot_2 = df_tot_2.sort_values(by=['Payload size'], ascending=True)
df_tot_2 = df_tot_2.drop(columns=['Payload size'])

df_tot_2 = df_tot_2.reset_index(drop=True)

df_tot_2 = 1/df_tot_2
df_tot_2 = df_tot_2.mul(1000)

plt.rc('font', size=10)

scatterplot = df_tot_2.plot(style='.', grid='true')
scatterplot.set_xlabel('Package sent [n]')
scatterplot.set_ylabel('Data throughput [MB/s]')
# scatterplot.set_yscale("log");
# densityplot = df_tot_2.plot.density(grid='true', xlim=[0.2, 0.9])
# densityplot.set_xlabel('Round trip time for one RPMsg package [us]')
# densityplot.set_ylabel('Probability density [%]')
plt.savefig('./img/kr260_echo_test_density.png', dpi=400, bbox_inches='tight')
return './img/kr260_echo_test_density.png'
#+END_SRC

#+RESULTS:
[[file:./img/kr260_echo_test_density.png]]


*** Report :ignore:
Now we have a working demonstration for RPMsg, a goal was to compare this system between boards.

Here is the complete sequence in order to archive a timely measured ~echo_test~ run, namely:
- Installation of the build dependencies
- Clone of the Xilinx repository
- Patching of the main source to add the time measurement
- Building of the test software
- Communication with the R5F, with reload of the firmware
#+BEGIN_SRC sh
sudo dnf install git make gcc binutils packagegroup-core-buildessential
sudo ln -s /usr/bin/aarch64-xilinx-linux-gcc /bin/cc
git clone https://github.com/OpenAMP/openamp-system-reference.git
cd openamp-system-reference/examples/linux/rpmsg-echo-test/
wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/raw/main/src/echo_test.patch
patch -u -b echo_test.c -i echo_test.patch
make
sudo -s
echo image_echo_test  > /sys/class/remoteproc/remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
./echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
#+END_SRC


The figure [[fig:kr260_echo_test_density]] below shows a comparison for the data
throughput that is reachable for a packages round trip of individual RPMsg
packages for both PetaLinux running on the KR260 board and Ubuntu running on the
KV260.

A difference exist but it is not as significant as to explain the rather slow
transfer rate when used in combination with ROS2 DDS.

#+ATTR_LATEX: :width .6\textwidth
#+CAPTION: A graph of the data transfer rate for individual packages to be transmitted and received back from the Linux.
#+NAME: fig:kr260_echo_test_density
[[file:./img/kr260_echo_test_density.png]]

This fast delay for data transmission was later confirmed by measurement done using an external logic analyser[fn:35].

** Setting up a static IP address for PetaLinux
This is not a trivial task in petalinux.

As it appears, the classic ~/etc/network/interfaces~ must be modified, however and
for some unknown reason the DHCP keep being used even when disabled, and the
actual static interface is not used until restarted.

Multiple steps are required in order to mitigate all of this.

First, we can make our standard ~interfaces~ configuration, in the  ~/etc/network/interfaces~:
#+BEGIN_SRC sh
# Wired or wireless interfaces
auto eth0
iface eth0 inet static
address 192.168.11.107
netmask 255.255.255.0
network 192.168.11.0
gateway 192.168.11.1
#+END_SRC

Then we need to have ~systemd~ to run a script after boot time to restart the ~eth0~ interface.

A very basic script, as follow need to be placed somewhere on the system, for example here, in the ~/home/root/net.sh~:
#+BEGIN_SRC sh
#!/bin/sh -e
ifdown eth0
ifup eth0
exit 0
#+END_SRC

Then, we want to create a ~systemd~ service that will run this script as ~idle~,
i.e. after all the rest. Said file, in our case named ~updown.service~ must be
placed in the ~/etc/systemd/system/~ directory:
#+BEGIN_SRC yaml
[Unit]
Description=Restart once more the eth0 network to enable the static IP

[Service]
Type=idle
ExecStart=/bin/sh /home/root/net.sh

[Install]
WantedBy=multi-user.target
#+END_SRC

Finally, as a ~root~ we need to set the correct right for these files and finally enabling the service before reboot:
#+BEGIN_SRC sh
sudo -s
chmod +x /home/root/net.sh
chmod 644 /etc/systemd/system/updown.service
systemctl enable updown.service
reboot now
#+END_SRC

With all of this, on the next reboot of the board, the static IP should be available alongside the DHCP IP.

** Note: good points for PetaLinux over Ubuntu :noexport:
+ The boot process in insanely faster: a few seconds for PetaLinux versus multiple minutes with Ubuntu.
+ +The fan is silent all the way through, and seemingly managed in a better way.+
  This seems to stop being true once we update the board packages with
  ~dnf~. Unknown reason for now. There is an issue with the ZynqMP Linux PIN
  control system, as visible in the ~dmesg~ log.
+ OpenAMP and the echo test app works fairly "out of the box" if configured
  properly during the build process.

* Footnotes
[fn:1] https://gitlab.com/sunoc/libmicroros_kv260 

[fn:35] https://gitlab.com/sunoc/saleae-logic-8-documentation

[fn:34] https://xilinx.github.io/kria-apps-docs/openamp/build/html/openamp_landing.html#openamp-demos 

[fn:33] If you search in the work directory, you might notice that three
differently named ~.xsa~ files exist. After a quick ~diff~ check, they appear to be
exactly identical.

[fn:32] Beware, the ~petalinux-build~ command execution takes a lot of time. 

[fn:31] https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+SOMs+Starter+Kits#K26-Boot-Firmware-Updates 

[fn:29] As of the time of writing this section, it was recommended[fn:31] to be
using the boot firmware in version 2022.2. Thus the software pack for the board
will also be using this version.

[fn:28] It is to be noted that the ~source~ command will run best on ~bash~. Trying
to run it on ~zsh~ for ex. will cause issues. This can be enforced with the
command ~sudo dpkg-reconfigure bash~.

[fn:27] https://github.com/eProsima/Micro-XRCE-DDS-Agent/blob/develop/src/cpp/transport/custom/CustomAgent.cpp

[fn:26] https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2022-2.html

[fn:25] https://xilinx.github.io/kria-apps-docs/kv260/2021.1/build/html/docs/build_petalinux.html

[fn:24] It is to be noted that for this part, the "other" KRIA board (KR260) was
used instead of the KV260 that was being used for everything tried on top of
Ubuntu. No significant difference should be noted.

[fn:23] micro-ROS Client firmware version 0.1, the first working version: https://gitlab.com/sunoc/libmicroros_kv260/-/tree/0.1

[fn:22] The ~--verbose 6~ allows to see the maximum amount of information about the data being transmitted. 

[fn:21] The ~--dev /dev/null~ option is only a placeholder as the serial requires it but not RPMsg.

[fn:20] micro-ROS ping pong test firmware repository: https://gitlab.com/sunoc/libmicroros_kv260 

[fn:19] This will be done with ROS2 agents "custom transport"  system,
which has little documentation. Some [[https://github.com/micro-ROS/micro_ros_setup/issues/383][discussions]] about it exist though.

[fn:18] This information was eventually found on a discussion in a [[https://github.com/micro-ROS/micro_ros_setup/issues/591][GitHub Issue thread]]. 

[fn:17] You need to be careful to have you shell in the "correct" space: these command need to be run inside
the container in which the previous setup were install, not on the host running the container system.
The hostname should help you to figure out where you are.

[fn:16] This is an example and this situation can become a security issue. It would be a better practice
in a production environment to map only the devices that are actually in use.

[fn:15] This command installs a complete "desktop" version of ROS2, containing many
useful package for our project.
If space is a constraint, different, less complete packages can be install.
Please refer to the official documentation about it.

[fn:14] The ~curl~ command from the guide does not work through the school proxy,
but the command ~wget~ used instead does work. The key is then moved to the correct spot with ~mv~. 

[fn:13] As always, this configuration was tested solely on Ubuntu LTS 22.04,
with the ROS2 versions ~Humble~ and then ~Iron~ being deployed.
Other combination of versions should work as well, but they are not
tested for this guide. In case of doubt or problem, please refer to the official documentation. 

[fn:12] It is also important to note that the ~echo_test~ part is specific for the
RPMsg base demonstration firmware. It is not to be used for other firmware.
The instruction to build and use this particular program on the Kria Linux
is visible in the section [[RPMsg ~echo_test~ software]].

[fn:11] In this sequence, we are entering a root shell with ~sudo -s~, but this can
also be archived by putting the commands in a script to be executed with ~sudo~. 

[fn:10] Note that in that case, we are retrieving the binary for a project
named ~rpmsg_pingpong_microros_lib~.
You own path will vary depending on how your project was named in the first place.
Obviously, the ~SSH~ connection parameters will also be specific to your case.
The ~ubuntu@192.168.1.10~ set here are merely an example.

[fn:9] Both files are also visible in the appendixes [[Custom tool-chain CMake settings]]
and [[Custom Colcon meta settings]] the end of this report.}

[fn:8] If Docker is not set up on your machine, you can follow the guide on [[https://docs.docker.com/engine/install/ubuntu/][the official website]].
When you can successfully run the "hello-world" container, you are good to go.

* References
[[bibliographystyle:ieeetr]]
[[bibliography:~/Nextcloud/PARA/3_Researches/Bibliography/references.bib]]
