% Created 2024-06-01 Sat 15:15
\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[newfloat]{minted}
\usepackage[a4paper, total={6.5in, 9in}]{geometry}
\usepackage{minted}
\setminted{breaklines}
\usepackage[utf8]{inputenc}
\renewcommand{\familydefault}{\sfdefault}
\usemintedstyle{vs}
\usepackage[most]{tcolorbox}
\usepackage{CJKutf8}
\usepackage{xurl}
\usepackage{fontawesome5}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\newcommand{\gitlab}[1]{%
\href{#1}{GitLab \faGitlab}}
\author{Vincent Conus\thanks{vincent.conus@protonmail.com}}
\date{2024-05-02}
\title{Setting up and using Xilinx KRIA KV260 and KR260\\\medskip
\large \begin{CJK}{UTF8}{min}南山大学\end{CJK}}
\hypersetup{
 pdfauthor={Vincent Conus},
 pdftitle={Setting up and using Xilinx KRIA KV260 and KR260},
 pdfkeywords={},
 pdfsubject={A report presenting how to use and set Xilinx's Kria board},
 pdfcreator={Emacs 30.0.50 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\begin{titlepage}
\centering
{\LARGE Setting up and using Xilinx KRIA KV260 and KR260 \par }
\vspace{5mm}
{\large \begin{CJK}{UTF8}{min}南山大学\end{CJK} \par}
\vspace{1cm}
{\large 2024-05-02 \par}
\vspace{2cm}
{\large Vincent Conus -  Source available at \gitlab{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation} \par}
\vspace{3cm}
\includegraphics[width=0.8\textwidth]{./img/boards}\end{titlepage}
\tableofcontents
\pagebreak
\section{Introduction \& motivation}
\label{sec:org608ce9a}
This guide will present how to setup and use Xilinx's KRIA boards, in particular
for running ROS on a host Ubuntu system, as well as for deploying
micro-ROS\cite{Belsare2023} as a firmware on the MCU part of this board's chip.

The use of this device in particular is interesting because of the presence of a
SoC comprising both a general purpose ARM core (Cortex A53), capable of running a Linux
distribution, as well as another ARM core, real-time enabled, capable to run a
RTOS (Cortex R5F). The figure \ref{fig:org262c6e0} below shows a schematic view of the overall system we
are trying to archive.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{img/map.png}
\caption{\label{fig:org262c6e0}The Linux and ROS2 environment (orange) will communicate with the real-time, FreeRTOS and micro-ROS side (blue) using RPMsg (shared memory).}
\end{figure}

This document will give a step-by-setep, chapter by chapter indication on how to go from a new board
to a system ready to be used for testing internal communication for ROS, between both types of cores
using the SoC shared memory.

\pagebreak
\section{Boot firmware update}
\label{sec:org907cb24}
The goal for the Linux side of the deployment is to
have the latest LTS version of Ubuntu up and running.

In order to be able to boot such a newer version of Linux, the
boot image of the board must first be updated.

The procedure is available in the official documentation\footnote{\url{https://docs.xilinx.com/r/en-US/ug1089-kv260-starter-kit/Firmware-Update}},
but I will present it step by step here.

\subsection{Getting the new firmware}
\label{sec:org8b6fefb}
A 2022.2 version of the board firmware is best in order to run the latest
version of Ubuntu or PetaLinux properly.

The image download link can be obtained at the Atlassian page\footnote{\url{https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+SOMs+Starter+Kits\#K26-Boot-Firmware-Updates}} on the topic,
in the table detailing what version is best suited for which board.

In our case, we want to access this\footnote{\url{https://www.xilinx.com/member/forms/download/design-license-xef.html?filename=BOOT-k26-starter-kit-20230516185703.bin}} page. AMD login will be asked, then
download of firmware can be done.

\subsection{Reaching the board recovery tool}
\label{sec:org6a61caa}
Now the firmware \texttt{.bin} image is available\footnote{Something that looks like \texttt{BOOT-k26-starter-kit-20230516185703.bin}, at the time of writing this section.}, it is possible to update it using the
boards recovery tool. Here are the steps that must be taken in order to reach
this tool and update the board:

\begin{itemize}
\item Power off the board and hold the firmware update button (FWUEN) when powering back the board.
\item Connect the board to your machine via a Ethernet cable.
This will obviously cut you internet access, so you should be set for that.
\item In the case of the KR260, the bottom right port should be used, as seen in the
figure \ref{fig:org23e1e82} below.
\item Select the wired network as your connection (must be "forced", since it
doesn't have internet access). To do so, you should disable the IPv6, and set
the IPv4 as manual, as visible in the figure \ref{fig:org1aa5381} hereafter.
\item Set a fixed IP address for your machine, in the \texttt{192.168.0.2/24}
range, except the specific \texttt{192.168.0.111}, which will be used by the
board, and \texttt{192.168.0.1} which is the DNS and gateway.
The netmask and gateway should also be respectively set to
\texttt{255.255.255.0} and \texttt{192.168.0.1}.
\item Unplug the board power cord again. Hold the firmware update button (FWUEN)
when powering back the board.
\item Using a web browser on your host machine, access \texttt{http://192.168.0.111}. Thou
shall now see the interface, as visible on the figure \ref{fig:orgf542113} below. If
the page struggle to appear, you should try to un-plug and re-plug the
Ethernet cable.
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.4\textwidth]{img/krport.png}
\caption{\label{fig:org23e1e82}Port to be used for the Ethernet Boot Recovery Tool access on the KR260 board.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{img/ipv4set.png}
\caption{\label{fig:org1aa5381}IPv4 settings for accessing the Recovery Tool.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=1\textwidth]{img/recovery.png}
\caption{\label{fig:orgf542113}The recovery tool for the board, access from Firefox. We can see board information at the center, and the tools to upload the firmware at the bottom of the page.}
\end{figure}

\subsection{Updating the boot firmware}
\label{sec:orga88698e}
From this "recovery" page, it is possible to upload the \texttt{.bin} file downloaded previously onto
the board using the "Recover Image" section at the bottom right of the page.

The board can be re-booted afterwards.
\clearpage
\section{Installing Ubuntu LTS 22.04}
\label{sec:org4edd679}
Withe the boot firmware being up-to-date, we can proceed to install a Linux distribution
on our Kria board. The step needed to archive a full installation of Ubuntu LTS 22.04
will be presented in this section\footnote{The same procedure should work for other versions of Ubuntu, as long as they
support the Kria board, but for this report and project, only the LTS 22.04 was tested
(as of 2023-08-30).}. The figure \ref{fig:org3c0e67a} below shows
where this operating system sits in the general system we are implementing.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/map_linux.png}
\caption{\label{fig:org3c0e67a}The Linux operating system (red border)runs on the APU (application, general purpose) side of the Kria board CPU. It is the base layer for the ROS2 system.}
\end{figure}

\subsection{Preparing and booting a Ubuntu 22.04 media}
\label{sec:orga04efe6}
An \href{https://ubuntu.com/download/amd-xilinx}{official Ubuntu image} exists and is
provided by Xilinx, allowing the OS installation to be quick and
straightforward.
Ubuntu is a common and easy to use distribution. Furthermore,
it allows to install ROS2 as a package, which is most convenient and will be
done later in this guide.

Once the image has been downloaded at \href{https://ubuntu.com/download/amd-xilinx}{Canonical's page}
we can flash it onto the SD card, with the following instructions.

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
\textbf{DANGER}: The next part involve the \texttt{dd} command writing on disks!!!
As always with the dd command, thou have to be \textbf{VERY} careful on what arguments
thou give. Selecting the wrong disk will result on the destruction of
thy data !!
\uline{If you are unsure of what to do, seek assistance !}
\end{tcolorbox}

With the image available on thy machine and a SD card visible as \texttt{/dev/sda} device\footnote{Again, it is \uline{critical} to be 100$\backslash$% certain that you are working with
the correct device!}
one can simply run the \texttt{dd} command as follow to write the image to a previously formatted drive (here \texttt{/dev/sda}):

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
unxz iot-limerick-kria-classic-desktop-2204-x07-20230302-63.img.xz
sudo dd if=iot-limerick-kria-classic-desktop-2204-x07-20230302-63.img \
     of=/dev/sda status=progress bs=8M && sync
\end{minted}


Once the SD card is flashed and put back in the board, the micro-USB cable can be
connected from the PC to the board. It is then possible to
connect to the board in serial with an appropriate tool, for example \texttt{picocom},
as in the following example (the serial port that "appeared" was the \texttt{/dev/ttyUSB1} in this case,
and the 115200 bit-rate is the default value for the board):

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo picocom /dev/ttyUSB1 -b 115200
\end{minted}

In my case, I am using Emacs's \texttt{serial-term}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
M-x serial-term RET /dev/ttyUSB1 RET 115200 RET
\end{minted}

The default username / password pair for the very first boot is \texttt{ubuntu} and \texttt{ubuntu}. You will then be prompted to enter a new password.

Once logged in, it is typically easier and more convenient to connect the board
using SSH. When the board is connected to the network, it is possible to know
it's IP address with the \texttt{IP} command; then it is possible to connect to
the board with ssh, as follow (example, with the first command to be run on the board
and the second one on the host PC, both without the first placeholder hostnames):
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
kria# ip addr

host# ssh ubuntu@192.168.4.11
\end{minted}

\subsection{Network and admin setups}
\label{sec:org530a03c}
This section presents a variety of extra convenience configurations
that can be used when setting-up the Kria board.

\subsubsection{Static IP address}
\label{sec:org158e635}
A static IP can be set by writing the following
configuration into your \texttt{netplan} configuration file\footnote{The \texttt{chmod} command is used to update the permissions and silence some warnings}.

The name of the files might vary:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo chmod 0600 /etc/netplan/50-cloud-init.yaml 
sudo nano /etc/netplan/50-cloud-init.yaml
\end{minted}

You can then set the wanted IP as follow\footnote{For the routing part, it is key to have the \texttt{to} with a \texttt{'-'} in front of
it; and then the \texttt{via} without, but aligned with the \texttt{t}.}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{yaml}
network:
  renderer: NetworkManager
  version: 2
  ethernets:
    eth0:
      dhcp4: false
      addresses:
        - 192.168.11.107/24
      routes:
        - to: default
          via: 192.168.11.1
      nameservers:
        addresses: [192.168.11.1]
\end{minted}

Finally, the change in settings can be applied
as follow:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo netplan apply
\end{minted}

\subsubsection{Proxy and DNS}
\label{sec:orgb2613a9}
An issue that can occur when connecting the board to the internet is the
conflicting situation with the university proxy.
Indeed, as the network at Nanzan University requires to go through a proxy,
some DNS errors appeared.

In that case, it might become needed to setup the proxy for the school.

This can be done as follow, by exporting a https base proxy configuration
containing you AXIA credentials (this is specific to Nanzan University IT system),
then by consolidating the configuration for other types of connections in the \texttt{bashrc}:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
export https_proxy="http://<AXIA_username>:\
       <AXIA_psw>@proxy.ic.nanzan-u.ac.jp:8080"

echo "export http_proxy=\""$https_proxy"\"" >> ~/.bashrc
echo "export https_proxy=\""$https_proxy"\"" >> ~/.bashrc
echo "export ftp_proxy=\""$https_proxy"\"" >> ~/.bashrc
echo "export no_proxy=\"localhost, 127.0.0.1,::1\"" >> ~/.bashrc
\end{minted}

Eventually the board can be rebooted in order for the setup to get applied cleanly.

\subsubsection{\texttt{root} password}
\label{sec:org02f8451}
\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
\textbf{WARNING}: Depending on your use-case, the setup presented in this
subsection can be a critical security breach as it remove the need for a root
password to access the admin functions of the board's Linux.
\uline{When in doubt, do not apply this configuration!!}
\end{tcolorbox}

If you board does not hold important data
and is available to you only, for test or development,
it might be convenient for the \texttt{sudo} tool to not ask for the
password all the time.
This change can be done by editing the sudoers file, and
adding the parameter \texttt{NOPASSWD}
at the \texttt{sudo} line:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo visudo

%sudo   ALL=(ALL:ALL) NOPASSWD: ALL
\end{minted}

Again, this is merely a convenience setup for devices staying at you desk. If
the board is meant to be used in any kind of production setup, a password
should be set for making administration tasks.

With all of these settings, you should be able to update the software of your
board without any issues:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get update
sudo apt-get dist-upgrade
sudo reboot now
\end{minted}

\subsubsection{Adding Xilinx specific repositories}
\label{sec:org6fe4a4d}
The following commands will add \texttt{PPA} repositories that are specific for Xilinx boards using Ubuntu.
It is then possible to update the package list and eventually upgrade to some new packages.
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo add-apt-repository ppa:ubuntu-xilinx/updates
sudo add-apt-repository ppa:xilinx-apps/ppa
sudo apt update
sudo apt upgrade
\end{minted}

\subsubsection{Purging \texttt{snap}}
\label{sec:org008a1ad}
As the desktop-specific software are not used at all in the case
of our project, there are some packages that can be purges in order for the
system to become more lightweight.

In particular, the main issue with Ubuntu systems is the forced integration of
Snap packages. Here are the command to use in order to remove all of that.
These steps take a lot of time and need to be executed in that specific order\footnote{The \texttt{snap} packages depends on each others. Dependencies
cannot be remove before the package(s) that depends on them,
thus the specific delete order.},
but the system fan runs sensibly slower without all of this stuff:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo systemctl disable snapd.service
sudo systemctl disable snapd.socket
sudo systemctl disable snapd.seeded.service

sudo snap list #show installed package, remove then all:
sudo snap remove --purge firefox
sudo snap remove --purge gnome-3-38-2004
sudo snap remove --purge gnome-42-2204
sudo snap remove --purge gtk-common-themes
sudo snap remove --purge snapd-desktop-integration
sudo snap remove --purge snap-store
sudo snap remove --purge bare
sudo snap remove --purge core20
sudo snap remove --purge core22
sudo snap remove --purge snapd
sudo snap list # check that everything is uninstalled

sudo rm -rf /var/cache/snapd/
sudo rm -rf ~/snap
sudo apt autoremove --purge snapd

# check once more that there is no more snap on the system
systemctl list-units | grep snapd 
\end{minted}

\subsubsection{Other unused heavy packages}
\label{sec:org7a93072}
Some other pieces of software can safely be removed since the desktop is
not to be used:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get autoremove --purge yaru-theme-icon \
     fonts-noto-cjk yaru-theme-gtk vim-runtime \
     ubuntu-wallpapers-jammy humanity-icon-theme

sudo apt-get autoclean
sudo reboot now
\end{minted}

\subsubsection{Slow boot services to disable}
\label{sec:org9ccd343}
These packages (in particular the first one) are taking up a LOT of time at boot while providing no benefits\footnote{The CUPS and Docker services will be activated when used instead of during boot time.}.

It is possible to disable them as follow:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo systemctl disable systemd-networkd-wait-online.service
sudo systemctl disable NetworkManager-wait-online.service
sudo systemctl disable cups.service
sudo systemctl disable docker.service
sudo systemctl disable containerd.service
sudo systemctl disable cloud-init-local.service
\end{minted}

Additional, potentially unused services can be found using the very handy command:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo systemd-analyze blame
\end{minted}

\subsubsection{Jupyter notebook setup}
\label{sec:org8ccd1e6}
Here are some instruction on how to install and setup Jupyter on a KRIA board,
accessing it remotely and using it for making data analysis.

The following commands will set the required packages and install Jupyter itself\footnote{Alongside other packages useful for data analysis, such as \texttt{pandas} or \texttt{numpy}.}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get update && sudo apt-get install python3 python3-pip python3-venv python3-virtualenv

virtualenv myjupyter
source ./myjupyter/bin/activate
python3 -m pip install jupyter pandas numpy matplotlib scipy

sudo reboot now
\end{minted}

Then in a terminal on your host machine (not on the KRIA board), you can run the following command\footnote{In this example, the full \texttt{username@IP} is used, but a \texttt{.ssh/config} is also usable.} to bind local ports:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
ssh -L 8888:localhost:8888 ubuntu@192.168.11.107
\end{minted}

Then on the opened SSH shell to the KRIA board:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source ./myjupyter/bin/activate
jupyter notebook
\end{minted}

From there, it is possible to use the displayed URL (something that looks like
\texttt{http://localhost:8888/tree?token}) to access the remote Notebook system from a local web browser.
It is possible to do so with \texttt{localhost} since we have the \texttt{ssh} port map connection going on.

Eventually creating Notebooks and stuff, it is possible to obtain a situation like shown in the figure \ref{fig:org170033a} below.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{img/jupyter.png}
\caption{\label{fig:org170033a}A test Jupyter Notebook for CSV data analysis.}
\end{figure}

\subsubsection{Enabling \texttt{remoteproc} with Device-Tree Overlay patching}
\label{sec:org9f8bd3b}
One of the advantage of this Kria board, as cited previously, is the presence of
multiple types of core (APU, MCU, FPGA) on the same chip.

The part in focus in this guide is the usage of both the APU, running
a Linux distribution and ROS2; and the MCU, running FreeRTOS and micro-ROS.
Online available guides\footnote{A \href{https://speakerdeck.com/fixstars/fpga-seminar-12-fixstars-corporation-20220727}{slideshow} (JP) from Fixstar employees presents how to use the device
tree to enable the communication between the cores.} \textsuperscript{,}\,\footnote{A \href{https://zenn.dev/ryuz88/articles/kv260\_setup\_memo\_ubuntu22 }{blog post} (JP) shows all major steps on how to enable the \texttt{remoteproc}.} also provide information on how to deploy these types
of systems and enabling \texttt{remoteproc} for the Kria board, but this guide
will show a step-by-step, tried process to have a heterogeneous system
up and running.

The communication between both side is meant to be done using shared memory, but
some extra setup is required in order to be running the real-time firmware, in particular
for deploying micro-ROS on it.

As a first step in that direction, this section of the report
will present how to setup and use as an example firmware that utilizes the
\texttt{remoteproc} device in Linux in order to access shared memory
and communicate with the real-time firmware using the RPMsg system.

The communication system and interaction from the Linux side towards the real-time capable core
is not enabled by default within the Ubuntu image provided by Xilinx.

In that regard, some modification of the device tree overlay (DTO) is required in order to have
the \texttt{remoteproc} system starting.

Firstly, we need to get the original firmware device tree, converted
into a readable format (DTS):

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo dtc /sys/firmware/fdt 2> /dev/null > system.dts
\end{minted}

Then, a custom-made patch file can be downloaded and applied.
This file is available at the URL visible in the command below
but also in this report appendix \ref{sec:org731fdfb}.

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/raw/7a8f7c4e66e09b9d66aba8d2e08fc446ff485ca8/src/system.patch

patch system.dts < system.patch
\end{minted}


As for the board to be able to reserve the correct amount of memory with the new settings, some
\texttt{cma} kernel configuration is needed\footnote{The overlapping memory will not prevent the board to boot,
but it disables the PWM for the CPU fan, which will then run at full speed, making noise.}:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo nano /etc/default/flash-kernel

LINUX_KERNEL_CMDLINE="quiet splash cma=512M cpuidle.off=1"
LINUX_KERNEL_CMDLINE_DEFAULTS=""
sudo flash-kernel
\end{minted}

Now the DTS file has been modified, one can regenerate the binary and place it on the \texttt{/boot} partition
and reboot the board:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
dtc -I dts -O dtb system.dts -o user-override.dtb
sudo mv user-override.dtb /boot/firmware/
sudo reboot now
\end{minted}

After rebooting, you can check the content of the \verb|remoteproc| system directory,
and a \texttt{remoteproc0} device should be visible, as follow:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
ls /sys/class/remoteproc/
#  remoteproc0
\end{minted}

If it is the case, it means that the patch was successful and  that the remote processor is
ready to be used!
\pagebreak

\subsubsection{Installing Docker}
\label{sec:org470b97c}
It is possible to have a version of Docker installed simply by using the available repository,
but since we are on Ubuntu, a PPA is available from Docker in order to have the most up-to-date version.

Following \href{https://docs.docker.com/engine/install/ubuntu/\#install-using-the-repository}{the official documentation}, the following steps can be taken to install the latest version of
Docker on a Ubuntu system. The last command is meant to test the install.
If everything went smoothly, you should see something similar to what is presented
in the figure \ref{fig:org0bb8032} below, after the commands:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

sudo chmod a+r /etc/apt/keyrings/docker.gpg

echo \
    "deb [arch="$(dpkg --print-architecture)" \
  signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  "$(. /etc/os-release && \
         echo "$VERSION_CODENAME")" stable" | \
    sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli \
     containerd.io docker-buildx-plugin docker-compose-plugin
sudo usermod -aG docker $USER
newgrp docker

docker run hello-world
\end{minted}

\begin{figure}[htbp]
\centering
\includegraphics[width=.7\textwidth]{img/hello-docker.png}
\caption{\label{fig:org0bb8032}The return of a successful run of the \texttt{hello world} test Docker container.}
\end{figure}

\subsubsection{Adding a swap partition}
\label{sec:orgfb32113}
This part is very optional, in particular as it might slow down a bit the
boot time of the board (\textasciitilde{}2s), however it might become handy to have swap memory
available to avoid system failure under heavy use.

This whole procedure must be done externally, with the board system SD card
mounted on a host PC as an external volume.  As it is highly platform dependant,
I will not give a detailed explanation on how to do it, yet here are the key
points that should be done:
\begin{itemize}
\item Shutdown the Kria board, take out the SD card and put it in a host machine.
\item Make sure the disk is visible.
\item Make sure all volumes are \textbf{unmounted}.
\item Resize the main \texttt{root} partition (\textbf{not} the \texttt{boot}) so a space the size of the
wanted swap is free \textbf{after} the partition. You'd want something around 1GB.
\item In the empty space, create a new partition, which type is "linux swap".
\item Find and take note of the UUID of the new partition. This is useful hereafter.
\item \texttt{sync}
\item Un-mount everything, eject SD card.
\item Put the SD card back in the Kria.
\item Boot back to Ubuntu.
\end{itemize}

Going back on the Kria board Ubuntu after boot, the \texttt{/etc/fstab} file can be
updated as follow, modulo your actual UUID for the newly created partition, to
enable swap at boot time.
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo -s
echo "UUID=8b13ed05-a91d-4x50-a44a-e654a0c67a2c none   swap    sw      0       0" >> /etc/fstab
reboot now
\end{minted}

\subsubsection{{\bfseries\sffamily TODO} Using a PetaLinux kernel in Ubuntu}
\label{sec:org24ea273}
\clearpage
\section{RPMsg standalone evaluation}
\label{sec:orgc4ad07f}
\subsection{{\bfseries\sffamily TODO} RPMsg Cortex R5F demonstration firmware}
\label{sec:org51ff595}
\subsection{RPMsg \texttt{echo\_test} software}
\label{sec:orgdde3900}
In order to test the deployment of the firmware on the R5F side, and in particular
to test the RPMsg function, we need some program on the Linux side of the Kria
board to "talk" with the real-time side.

Some source is provided by Xilinx to build a demonstration software that does
this purpose: specifically interact with the demonstration firmware.

Here are the steps required to obtain the sources, and build the program.

As a reminder, this is meant to be done on the Linux running on the
Kria board, NOT on your host machine !

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
git clone https://github.com/Xilinx/meta-openamp.git
cd  meta-openamp
git checkout xlnx-rel-v2022.2
cd  ./recipes-openamp/rpmsg-examples/rpmsg-echo-test
make
sudo ln -s $(pwd)/echo_test /usr/bin/
\end{minted}

Once this is done, it it possible to run the test program from the Kria board's Ubuntu
by running the \texttt{echo\_test} command.

\clearpage
\section{Building micro-ROS as a static library}
\label{sec:org70e6360}
This section will present the way to build manually the micro-ROS system as static library
that can be used to port it to a different platform.

\subsection{Initial setup}
\label{sec:org4d2abba}
In this section, the goal is to build the micro-ROS library in order to be
able to integrate it's functions into our Cortex R5F firmware.

All of this should be done via cross-compiling on a host machine, however
it is most common in the guides about micro-ROS to build the firmware and libraries within a Docker,
so we can have access of the ROS environment without installing it permanently.

One can simply run this command to summon a ROS2 Docker\footnote{If Docker is not set up on your machine, you can follow the guide on \href{https://docs.docker.com/engine/install/ubuntu/}{the official website}.
When you can successfully run the "hello-world" container, you are good to go.} with the wanted version,
but first we also need to check the cross-compilation tools.

We are downloading the latest \texttt{arm-none-eabi} gcc compiler directly from the ARM website.

The cross-compilation tool can then be extracted, set as our \texttt{toolchain} variable,
then passed as a parameter when creating the Docker container:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
pushd /home/$USER/Downloads
wget https://developer.arm.com/-/media/Files/downloads/gnu/13.2.rel1/binrel/arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz
tar -xvf arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz
popd

toolchain="/home/$USER/Downloads/arm-gnu-toolchain-13.2.Rel1-x86_64-arm-none-eabi/"


docker run -d --name ros_build -it --net=host \
       --hostname ros_build \
       -v $toolchain:/armr5-toolchain \
       --privileged ros:iron
\end{minted}

Now the container named \texttt{ros\_build} was created, it is possible to "enter" it, and having access
to the tools in it by running the following command that will open a \texttt{bash} shell in said container:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
docker exec -it ros_build bash
\end{minted}

\subsection{Building the static library}
\label{sec:org9461c53}
Now we are in the ROS2 container, we can build the micro-ROS firmware as presented
in the \href{https://micro.ros.org/docs/tutorials/advanced/create\\\_custom\\\_static\\\_library}{dedicated micro-ROS guide}:
\#+BEGIN\textsubscript{SRC} sh
echo 127.0.0.1 \$HOSTNAME >> /etc/hosts
sudo apt update 
sudo apt-get -y install python3-pip $\backslash$
     wget $\backslash$
     nano

. /opt/ros/\$ROS\textsubscript{DISTRO}/setup.bash

mkdir microros\textsubscript{ws}
cd microros\textsubscript{ws}
git clone -b \$ROS\textsubscript{DISTRO} $\backslash$
    \url{https://github.com/micro-ROS/micro\_ros\_setup.git} $\backslash$
\clearpage
\section{Setting up a Vitis IDE project}
\label{sec:org0db0d05}
As visible in the official documentation\footnote{\url{https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1837006921/OpenAMP+Base+Hardware+Configurations/\#Build-RPU-firmware}}, this section will present the required
steps for building a new firmware for the R5F core of our Kria board.

The goal here is to have a demonstration firmware running,
able to use the RPMsg system to communicate with the Linux APU.
The figure \ref{fig:orgeba369e} below shows where the real-time firmware
is positioned in the global project.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/map_microros.png}
\caption{\label{fig:orgeba369e}The FreeRTOS firmware and it's application (red border) are running on the real-time capable side of the Kria CPU. A micro-ROS application is shown here, but any real-time firmware will be deployed in the same way.}
\end{figure}

\subsection{Setting up the IDE}
\label{sec:orge9d5314}
Xilinx's Vitis IDE is the recommended tool used to build software for the Xilinx boards.
It also include the tools to interact with the FPGA part, making the whole
software very large (around 200GB of disk usage).

However, this large tool-set allows for a convenient development environment, in particular
in our case where some FreeRTOS system, with many dependencies is to be build.

The installer can be found on Xilinx download page\footnote{\url{https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html}}. You will need to get
a file named something like \texttt{Xilinx\_Unified\_2022.2\_1014\_8888\_Lin64.bin}\footnote{The name of the installer binary file might change as a new version of
the IDE is release every year or so.}.

Vitis IDE installer is compatible with versions of Ubuntu, among other distributions,
but not officially yet for the 22.04 version.
Furthermore, the current install was tested on Pop OS, a distribution derived from Ubuntu.
However, even with this more unstable status, no major problems were encountered
with this tool during the development stages.

This guide will present a setup procedure that supposedly works for all distributions based on the newest
LTS from Ubuntu. For other Linux distributions or operating system, please refer to the official documentation.

\subsubsection{Dependencies \& installation}
\label{sec:org7cc45ee}
Some packages are required to be installed on the host system
in order for the installation process to happen successfully:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get -y update

sudo apt-get -y install libncurses-dev \
     ncurses-term \
     ncurses-base \
     ncurses-bin \
     libncurses5 \
     libtinfo5 \
     libncurses5-dev \
     libncursesw5-dev
\end{minted}

Once this is done, the previously downloaded binary installer can be executed:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
\end{minted}

If it is not possible to run the previous command, make the file executable with the \texttt{chmod} command:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo chmod +x ./Xilinx_Unified_2022.2_1014_8888_Lin64.bin
\end{minted}

From there you can follow the step-by-step graphical installer.
The directory chosen for the rest of this guide for the Xilinx directory
is directly the \texttt{\$HOME}, but the installation can be set elsewhere is needed.

\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black]
\textbf{WARNING}: This whole procedure can take up to multiple hours to complete
and is prone to failures (regarding missing dependencies, typically),
so your schedule should be arranged accordingly.
\end{tcolorbox}

\subsubsection{Platform configuration file}
\label{sec:org6a025f2}
With a Xilinx account, a \texttt{.bsp} archive can be downloaded for the taget platform\footnote{\url{https://www.xilinx.com/member/forms/download/xef.html?filename=xilinx-kr260-starterkit-v2022.2-10141622.bsp}}.

Once the file is downloaded, the following commands allows to "un-tar" it,
making th needed \texttt{.xsa} file accessible via a file explorer.

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
tar xvfz xilinx-kr260-starterkit-v2022.2-10141622.bsp
ls xilinx-kr260-starterkit-2022.2/hardware/xilinx-kr260-starterkit-2022.2/
\end{minted}


\subsubsection{[DEPRECATED] Platform configuration file generation}
\label{sec:orgaf3947c}
In order to have the libraries and configurations in the IDE ready to be used for our board,
we need to obtain some configuration files that are specific for the Kria KV260,
as presented in the Xilinx guide for Kria and Vitis\footnote{\url{https://xilinx.github.io/kria-apps-docs/kv260/2022.1/build/html/docs/build\_vitis\_platform.html?highlight=xsa}}.

A Xilinx dedicated repository\footnote{\url{https://github.com/Xilinx/kria-vitis-platforms}} is available for us to download  such configurations,
but they required to be built.

As for the dependencies, \texttt{Cmake}, \texttt{tcl} and \texttt{idn} will become needed in order to build the firmware.
Regarding \texttt{idn}, some version issue can happen, but as discussed in a thread on Xilinx's forum\footnote{\url{https://support.xilinx.com/s/question/0D52E00006jrzsYSAQ/platform-project-cannot-be-created-on-vitis?language=en\_US}},
if \texttt{libidn11} is specifically required but not available (it is the case for Ubuntu 22.04),
creating a symbolic link from the current, 12 version works as a workaround.

Here are the steps for installing the dependencies and building this configuration file:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get update
sudo apt-get install cmake tcl libidn11-dev \
     libidn-dev libidn12 idn
sudo ln -s /usr/lib/x86_64-linux-gnu/libidn.so.12 \
     /usr/lib/x86_64-linux-gnu/libidn.so.11

cd ~/Xilinx
git clone --recursive \
    https://github.com/Xilinx/kria-vitis-platforms.git
cd kria-vitis-platforms/k26/platforms
export XILINX_VIVADO=/home/$USER/Xilinx/Vivado/2022.2/
export XILINX_VITIS=/home/$USER/Xilinx/Vitis/2022.2/
make platform PLATFORM=k26_base_starter_kit
\end{minted}

\subsection{Setting up and building a new project for the Kria board}
\label{sec:orga19dbdc}
With the platform configuration files available, we can now use the IDE to generate a
new project for our board. The whole process will be described with screen captures and
captions.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project1.png}
\caption{\label{fig:org5b0f64a}We are starting with creating a "New Application Project" You should be greeted with this wizard window. Next.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project2.png}
\caption{\label{fig:org211cdf1}For the platform, we need to get our build Kria configuration. In the "Create a new platform" tab, click the "Browse\ldots{}" button.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project3.png}
\caption{\label{fig:orgaa126ba}In the file explorer, we should navigate in the "k26" directory, where the configuration file was build. From here we are looking for a ".xsa" file, located in a "hw" directory, as visible.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project4.png}
\caption{\label{fig:org00cb4c3}With the configuration file loaded, we can now select a name for our platform, but most importantly, we have to select the "psu Cortex5 0" core as a target. The other, Cortex 53 is the APU running Linux.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project6.png}
\caption{\label{fig:orged328b1}Here, we want to select "freertos10 xilinx" as our Operating System. The rest can remain unchanged.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project5.png}
\caption{\label{fig:orgf0c1e8e}In this next window, we can give a name to our firmware project. It is also critical here to select the core we want to build for. Once again, we want to use the "psu cortex5 0".}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project7.png}
\caption{\label{fig:orgcf0ff23}Finally, we can select the demonstration template we are going to use; here we go with "OpenAMP echo-test" since we want to have some simple try of the RPMsg system. Finish.}
\end{figure}

\pagebreak
In the Xilinx documentation, it is made mention of the addresses setting that should be checked in the \texttt{script.ld} file.
The values in the figure \ref{fig:orgf54f9cc} below look different from what could be set in the DTO for the Linux side, but they appear to
work for the example we are running, including the new DTO patch without overlapping memory:


\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/vitis_new/project_mem.png}
\caption{\label{fig:orgf54f9cc}lscript.ld memory configuration for the firmware memory setup. The same file is available as a whole in this repository's src directory.}
\end{figure}


Once your example project is built and you have a \texttt{.elf} file available, you can
jump directly in further sections to see how to deploy and use your firmware.

The section in between will present setup specifically needed for micro-ROS.

\subsection{Enabling the Stream Buffer system}
\label{sec:orgdc1bf70}
This is a subpart in the general configuration in the project related to some specific
functions for FreeRTOS threads messaging system, however, this point in particular
created so much pain I needed to include in early in this guide for not to forget about it
and keeping a clear track on how to enable this setting.

Indeed, two settings need to be enabled in order to be able to call
functions such as \texttt{xMessageBufferCreate}, useful when working with tasks
in FreeRTOS, as visible in the figure \ref{fig:orgd6635f2} below:

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./img/streambuffer.png}
\caption{\label{fig:orgd6635f2}Enabling Stream Buffer in the Vitis IDE setting: this is a setting that can be found in the "platform.spr" element of your project (the platform, not the firmware project itself). From that file, you can access the settings with the button "Modify BSP Settings", and then as visible, in the tab \texttt{freertos10\_xilinx}, it is needed to toggle here the \texttt{stream\_buffer} setting in the \texttt{kernel\_features}, from the default "false" to "true".}
\end{figure}

\pagebreak
The second setting is useful in the case when a buffer callback function is used, such as\\[0pt]
\texttt{xMessageBufferCreateWithCallback}.
In that case, you must include \texttt{\#define configUSE\_SB\_COMPLETED\_CALLBACK 1} on the top of you header
file (in our project, this will happen in the \texttt{microros.h} header file),
before the \texttt{\#include "FreeRTOS.h"} in order to override the setting from this include.

\subsection{Including micro-ROS to the real-time firmware}
\label{sec:orgc21f0cd}
Now we have a Vitis demonstration project available and the \texttt{libmicroros} static library
available, we can combine both by including this library into our Kria project.

On the host machine running the IDE, we can download the static library
and the include files from the Docker builder.
Here, we assume your Vitis IDE workspace sits in you home directory, at \texttt{\textasciitilde{}/workspace},
and that the Docker container is named \texttt{ros\_build}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
mkdir /home/$USER/workspace/microros_lib

docker cp ros_build:/microros_ws/firmware/build/\
       libmicroros.a /home/$USER/workspace/microros_lib/

docker cp ros_build:/microros_ws/firmware/build/include \
       /home/$USER/workspace/microros_lib/
\end{minted}

Many parameters are available to be set up in the IDE for the compilation tool-chain, but
the figures \ref{fig:orgcd64157} and \ref{fig:orgcca2509} below will show you a setup that worked to have the IDE
to recognize the include files and to be able to use them for compiling the firmware.

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./img/vitis_new/include.png}
\caption{\label{fig:orgcd64157}Firstly, in the "C/C++ Build" settings of your firmware project, under the "Settings" menu, you should find the gcc compiler "Directories". In here you should add the "include" directory of your library. Be careful however, if your include files are in a second layer of directory (as it is the case for libmicroros) you will need to include each sub-directory individually, as visible in this figure.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.8\textwidth]{./img/vitis_new/include2.png}
\caption{\label{fig:orgcca2509}Secondly, in the gcc linker "Libraries", you can add the top level directory of your library. In our case, it is the directory that contains both the "include" directory added earlier, and also the "libmicroros.a" file.}
\end{figure}

\pagebreak
With both of these setup in your project and as a minimal test to see if the setup was made correctly,
you should be able to include the following micro-ROS libraries into your project:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{c}
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
\end{minted}

The details for the inclusions and the use-case of the library will depend on the implementation
of the firmware itself.
\clearpage
\section{ROS2 host system setup}
\label{sec:orgfd8d394}
This is focused on the ROS2 system being used on the Kria board as a base to run and / or build
micro-ROS components.

The installation of ROS2 as a system will be presented, with
two different ways of approaching the problem.

As for the previous section, the figure \ref{fig:orgc392327} below shows what part
of the overall system we are talking about here.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/map_ros.png}
\caption{\label{fig:org1cb5190}The ROS2 middle (red border) runs on top of the Linux, on the general-purpose core of the Kria board.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.55\textwidth]{./img/agent_arch.png}
\caption{\label{fig:org4e85ca7}Methods architecture for the modified Agent node.}
\end{figure}

\subsection{On the host Linux ("bare-metal")}
\label{sec:org33e35f2}
Since an Ubuntu distribution is installed on the board, the installation of ROS2
can be done\footnote{As always, this configuration was tested solely on Ubuntu LTS 22.04,
with the ROS2 versions \texttt{Humble} and then \texttt{Iron} being deployed.
Other combination of versions should work as well, but they are not
tested for this guide. In case of doubt or problem, please refer to the official documentation.} in a standard way, using the repository.

An \href{https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html}{official documentation} is provided with ROS2 themselves with a step-by-step guide on how to install
ROS2 on a Ubuntu system\{\}.
We will be following this guide here\footnote{The \texttt{curl} command from the guide does not work through the school proxy,
but the command \texttt{wget} used instead does work. The key is then moved to the correct spot with \texttt{mv}.}.

Firstly, we need to update the locals, enable the universe Ubuntu repository,
get the key and add the repository for ROS2. This can be done as follow:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
locale  # check for UTF-8
sudo apt update && sudo apt install -y locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
locale  # verify settings

sudo apt install -y software-properties-common
sudo add-apt-repository universe
sudo apt update && sudo apt install -y curl wget

wget https://raw.githubusercontent.com/ros/rosdistro/master/ros.key
sudo mv ros.key /usr/share/keyrings/ros-archive-keyring.gpg
\end{minted}

Then, a thick one-liner is available to add the ROS2 repository to our system:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
echo "deb [arch=$(dpkg --print-architecture) \
signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] \
http://packages.ros.org/ros2/ubuntu $(. \
/etc/os-release && echo $UBUNTU_CODENAME) main" | \
    sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
\end{minted}

It is then possible to install ROS2\footnote{This command installs a complete "desktop" version of ROS2, containing many
useful package for our project.
If space is a constraint, different, less complete packages can be install.
Please refer to the official documentation about it.} as follow:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt update
sudo apt upgrade -y
sudo apt install -y ros-$ROS_DISTRO-desktop \
     ros-$ROS_DISTRO-ros-base \
     python3-argcomplete \
     ros-dev-tools
\end{minted}

Once installed, it is possible to test the system with a provided example.
You need to open two terminals and log wish SSH onto the board, then running
respectively:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source /opt/ros/$ROS_DISTRO/setup.bash
ros2 run demo_nodes_cpp talker
\end{minted}

And then:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source /opt/ros/$ROS_DISTRO/setup.bash
ros2 run demo_nodes_py listener
\end{minted}

You should be able to see the first terminal sending "Hello world" messages,
and the second one receiving then.

\subsection{In a container (Docker)}
\label{sec:org1fccfe4}
As containers are used to test and build micro-ROS configurations,
running ROS2 in a Docker  is a great way to have a reproducible configuration
of you system.

This part of the guide will present how to install Docker on the
Kria board and then how to use it to deploy the latest version of ROS2.
This section of the report assumes that Docker was installer on the target system
as presented in section \ref{sec:org470b97c}.

The following commands will pull a ROS container, version \texttt{iron}, and name it \texttt{ros\_build}.

A key part for having access to the interfaces (serial) is the mapping of the whole \texttt{/dev}
range of devices from the host machine to the internal \texttt{/dev} of the container\footnote{This is an example and this situation can become a security issue. It would be a better practice
in a production environment to map only the devices that are actually in use.}.
With the second command, we can execute \texttt{bash} as a way to open a terminal to the "inside" the container:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
docker run -d --name ros_agent -it --net=host -v \
       /dev:/dev --privileged ros:iron
docker exec -it ros_agent bash
\end{minted}

From there, it becomes possible to simply use ROS2 as you would for a bare-metal install,
and as presented in the section \ref{sec:org33e35f2} above:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source /opt/ros/$ROS_DISTRO/setup.bash

# Create a workspace and download the micro-ROS tools
mkdir microros_ws
cd microros_ws
git clone -b $ROS_DISTRO https://github.com/micro-ROS/\
    micro_ros_setup.git src/micro_ros_setup

# Update dependencies using rosdep
sudo apt update && rosdep update
rosdep install --from-paths src --ignore-src -y

# Install pip
sudo apt-get install python3-pip

# Build micro-ROS tools and source them
colcon build

# Download micro-ROS-Agent packages
source install/local_setup.bash
ros2 run micro_ros_setup create_agent_ws.sh

# Build step
ros2 run micro_ros_setup build_agent.sh

# Run a micro-ROS agent
ros2 run micro_ros_agent micro_ros_agent serial \
     --dev /dev/ttyUSB1
\end{minted}

Then once again in a similar way to the bare-metal deployment,  it is possible to run a demonstration
the ping-pong topic communication from a different shell\footnote{You need to be careful to have you shell in the "correct" space: these command need to be run inside
the container in which the previous setup were install, not on the host running the container system.
The hostname should help you to figure out where you are.}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source /opt/ros/$ROS_DISTRO/setup.bash

# Subscribe to micro-ROS ping topic
ros2 topic echo /microROS/ping
\end{minted}
\clearpage
\section{micro-ROS Client}
\label{sec:orga8dca46}
\subsection{micro-ROS adaptation for the firmware}
\label{sec:orgba09cb5}
Beyond the inclusion of the library itself, actually using the micro-ROS system
within an external project require more than just importing the needed
functions.

Indeed, if you would be just adding the various function for sending messages to
the general ROS2 network, you would face issues with four key aspects.
These are presented in the following dedicated sub-sections.

\subsubsection{Time functions}
\label{sec:org7ae0d57}
As micro-ROS can be used on a variety of board, it does not understand by itself
what time functions are meant to be used.

In that regard, some API-style function are being
used in the library and it is then needed for the person using a new board
to implement these function inner working using the board own time-related
function calls.

In particular for this part, the \texttt{clock\_gettime} function is key, and could
simply be implemented with some FreeRTOS time functions.

The end result for these implementation are visible in the appendix \ref{sec:orge8646b1},
and can be reused as-if for the Kria board setups.

\subsubsection{[DEPRECATED] Memory allocators}
\label{sec:org3e51616}
Similarly to the time function, it is required to re-implement some form of memory allocating
functions in order for the library to be able to work with such functions in a formalized way.

As for now, the current version of the allocator function can be seen in the
appendix \ref{sec:org9284958}, but the current setup is not
completely "clean", some further formatting, test and modification will be needed.

\subsubsection{Custom transport layer}
\label{sec:orgfaa5048}
This part is the key translation layer that needs to happen in order for the
DDS system from the micro-ROS library to be using the communication channel we
want it to.

A problem that had to be figured out lives in the fact that the operation of micro-ROS DDS
and the board's RPMsg communication system does not operate in the same fashion.

The former expects to have four functions ("open", "read", "write" and "close") that can
be called and used by the main system, while the latter relies on FreeRTOS callback
system, waiting on the service interrupt routine to be trigger by an incoming message.

This situation meant that we count not simple translate the communication layers from one
to another: a non-blocking polling and buffer system needed to be put into places.
The proposed solution that was implemented and that is currently being tested
is showed and detailed in the figure \ref{fig:org8631684} below.

The next figure \ref{fig:orga9fc240} show a more visual representation of the two tasks and the
functions used in them.

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\textwidth]{./img/tasks.png}
\caption{\label{fig:org8631684}Two tasks are being run concurrently in order to manage the communication situation, with binary semaphore-based lock-unlock system.\\[0pt]
 The role of the micro-ROS task (red) is to make the four functions ("open", "read", "write" and "close")  available and running the actual software function. In this example, polling the read function and writing back when something is receive (ping-pong function). The use of the \texttt{rpmsg\_send()} function is done directly from the micro-ROS task, bypassing the RPMsg task in this situation.\\[0pt]
 In the libmicroros implementation currently being developed, the micro-ROS task holds all the DDS and micro-ROS system, including the mentioned allocators function.\\[0pt]
 The RPMsg task (green) is used to firstly set the RPMsg communication with the Linux system, then it stays locked until the ISR (interrupt service routine) is triggered by an incoming message. The message is then passed to the micro-ROS task using a buffer.\\[0pt]
 When a shutdown signal is received from the Linux, both functions will gracefully close and are getting killed.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\textwidth]{./img/client_arch.png}
\caption{\label{fig:orga9fc240}Functions architecture for the Client firmware.}
\end{figure}

A version of this firmware is available at my gitlab repository\footnote{micro-ROS ping pong test firmware repository: \url{https://gitlab.com/sunoc/libmicroros\_kv260}}. This firmware was built using
Xilinx's IDE, which setup was presented in the section \ref{sec:orge9d5314}, however it was tested
and given the provided \texttt{Makefile} system, it is possible to modify and rebuild the firmware
without this specific tools, as long as the compiler is installed correctly.

Beyond the general two-tasks behavior of the figure \ref{fig:org8631684}, here are the main steps
of the execution of the firmware:
\begin{itemize}
\item During the RPMsg init phase (RPMsg task), a "hello" message is exchanged with the Linux side
to confirm the OpenAMP system is also ready there.
\item Memory allocations and custom transport function are set in the micro-ROS task.
\item The micro-ROS and it's \texttt{rclc} system run extensive initialization tasks to:
\begin{itemize}
\item Initialize the support system
\item Initialize the support node
\item Initialize the publishers
\item Initialize the subscribers
\end{itemize}
\item Finally, the ping-pong function become effective with the micro-ROS task
polling to receive some message and sending it back to the sender.
\end{itemize}


\clearpage
\subsection{Loading the firmware}
\label{sec:org7608166}
Having a version of our \texttt{.elf} firmware (with or without the included
micro-ROS library) built and loaded onto our Kria's Linux, we want to load and run it
on the Cortex micro-controller side.

As a reminder, the firmware can be loaded from the host machine IDE workspace
to the Kria board through \texttt{SSH} using the following command:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
scp /home/sunoc/workspace/rpmsg_pingpong_microros_lib/\
    Debug/rpmsg_pingpong_microros_lib.elf  ubuntu@192.168.1.10:/home/ubuntu/
\end{minted}

The following instructions will show how to use this binary file, and
in particular how to upload and start the firmware on the R5F real time core
from the Linux user-space\footnote{In this sequence, we are entering a root shell with \texttt{sudo -s}, but this can
also be archived by putting the commands in a script to be executed with \texttt{sudo}.}, to test a basic RPMsg setup\footnote{It is also important to note that the \texttt{echo\_test} part is specific for the
RPMsg base demonstration firmware. It is not to be used for other firmware.
The instruction to build and use this particular program on the Kria Linux
is visible in the section \ref{sec:orgdde3900}.}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo -s
mv image_echo_test /lib/firmware
echo image_echo_test  > /sys/class/remoteproc/\
     remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
\end{minted}

In this setup you need to be careful for the name of the \texttt{.elf} binary to be exactly used
in the first \texttt{mv} and \texttt{echo} command. In this example, the binary would be named
\texttt{image\_echo\_test.elf}, and moved from \texttt{\$HOME} to \texttt{/lib/firmware}.

The debug of the firmware itself is done by reading the "printf" visible from the serial
return of the board (typically a \texttt{/dev/ttyUSB1}), but two things are to be noted:
\begin{itemize}
\item If the \texttt{echo start} command fails, either the previous firmware run was not stopped,
or the new binary itself is impossible to run.
\item In general, if the \texttt{echo\_test} runs, it means that everything is okay and that
the RPMsg system worked successfully.
\end{itemize}

\clearpage
\subsubsection{Loading the firmware using JTAG and Vitis IDE}
\label{sec:org54f2c82}
This is more of an alternative way, but it is possible to load the Client
firmware onto the Cortex R5F onto the board from a host PC IDE, without booting or
using the Linux on the KRIA board itself.

This section will present the way to do so, and most critically, the steps that must
be taken beforehand on the host machine for that system to work.

There are two key advantaged to using this method:
\begin{itemize}
\item The load time for the firmware is real fast. In particular, re-loading the
firmware doesn't require to reboot the entire Linux system.
\item IDE debugging available. Running the JTAG on the board allows for the firmware
to be debugger in a easier way.
\end{itemize}

\subsection{Testing \texttt{xsct} and running the drivers}
\label{sec:org698c6fc}
Firstly, this part of the guide assumes that a version of the Vitis Classic IDE
was installed on the host system. Some of the needed tools to test the working of the JTAG
system are located in the installation directory of the IDE.

In my case, I'll have to go to \texttt{\textasciitilde{}/tools/Xilinx/Vitis/2023.2}, but your mileage might vary
depending on the settings you choose during the IDE installation and also the version of
the IDE itself.

\begin{enumerate}
\item Drivers
\label{sec:org6c3082c}
Firstly, we need to load some drivers in order for the JTAG USB system to work:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{bash}
sudo ./data/xicom/cable_drivers/lin64/install_script/install_drivers/install_drivers
\end{minted}

\item \texttt{dialout} access
\label{sec:org9c1b39d}
It is also much needed for the user that runs the IDE to have read/write access to the
USB devices. This can be done as follow, as root:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
usermod -aG dialout ${USER}
\end{minted}

You'll need to log out and log back it for the changes to apply though.

\item TCL JTAG boot
\label{sec:orge915ecd}
A short TCL program was provided by Honda-sensei and should be loaded in order
for the board to boot in JTAG mode.
The following code block shows the TCL, and it should be saved somewhere, for example
in \texttt{\textasciitilde{}/Downloads/boot\_jtag.tcl}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{tcl}
proc boot_jtag { } {
############################
# Switch to JTAG boot mode #
############################
targets -set -filter {name =~ "PSU"}
# update multiboot to ZERO
mwr 0xffca0010 0x0
# change boot mode to JTAG
mwr 0xff5e0200 0x0100
# reset
rst -system
}


# Jtag connection 
connect
puts stdout "Connect Jtag"

# Switching to JtagBoot
puts -nonewline stdout "Start transition to jtag boot mode..."
boot_jtag
puts stdout "done."

# Jtag disconnection
puts -nonewline stdout "Disconnect Jtag..."
disconnect
puts stdout "done."
\end{minted}

Eventually it is possible to load the JTAG boot script as follow:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{bash}
cd ~/tools/Xilinx/Vitis/2023.2
source settings64.sh
xsct -norlwrap ~/Downloads/boot_jtag.tcl
\end{minted}
\end{enumerate}

\subsubsection{Vitis IDE classic}
\label{sec:org9758d74}
Note that the steps presented here must be taken after running the \texttt{xsct} command; without rebooting the board in the mean time.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/jtag/design.png}
\caption{\label{fig:org19af4e1}With a project meant to be build and run on the Cortex R5F, you must first produce the \texttt{.elf} binary file.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/jtag/debug_config.png}
\caption{\label{fig:org16ed287}Then you can open the Debug Configuration window.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/jtag/debug_config2.png}
\caption{\label{fig:org4dd6189}All parameters should stay the same. You can then run "Debug".}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/jtag/console.png}
\caption{\label{fig:orga883ce9}The XSCT console will confirm the successful load of the firmware. If not, you will get error messages and should reboot the board.}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/jtag/run.png}
\caption{\label{fig:orgc392327}Selecting the Cortex R5, core \#0, you can then run the application.}
\end{figure}

\clearpage
\section{micro-ROS XRCE-DDS Agent}
\label{sec:org11c0cec}
The micro-ROS Agent on the ROS2 side is the last piece of the puzzle needed to
allow our DDS environment to use RPMsg as a mean of communication, as visible
on the schematic of the figure \ref{fig:org0b87e28} below.
In particular, it will be useful to modify this agent in order to archive
the full RPMsg communication for ROS2\footnote{This will be done with ROS2 agents "custom transport"  system,
which has little documentation. Some \href{https://github.com/micro-ROS/micro\_ros\_setup/issues/383}{discussions} about it exist though.}.
An \href{https://micro.ros.org/docs/tutorials/advanced/create\_custom\_transports/}{official documentation} exists, but it gives little to no detail
on how to deploy such modified, custom transport setup.
This part of the guide will focus on it.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/map_agent.png}
\caption{\label{fig:org0b87e28}The agent (red border) allows for a micro-ROS instance to communicate with a ROS2 system. It is deployed on the Linux side, as a ROS2 node.}
\end{figure}

\subsection{Building a XRCE-DDS agent in a Docker}
\label{sec:org764aa64}
The same command presented above for running a custom agent "bare-metal" can be
run inside a Docker.

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
docker run -d --name XRCE_DDS_Agent -it --net=host -v \
       /dev:/dev --privileged ros:iron
docker exec -it XRCE_DDS_Agent bash
\end{minted}


\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
git clone https://github.com/eProsima/Micro-XRCE-DDS-Agent.git
cd Micro-XRCE-DDS-Agent
docker build -t xrce-dds-agent .
docker run -it --privileged -v /dev:/dev xrce-dds-agent serial \
       --dev /dev/ttyACM0
\end{minted}

\subsection{Building the Agent version with a modified transport}
\label{sec:org2e3b5c2}
The first working implementation of the DDS over RPMsg happened over a
XRCE-DDS agent whose \texttt{serial} transport layer has been modified in order
to use OpenAMP's RPMsg instead.

The build process it the same as usual, just pulling from my fork of eProsima repository
and using the \texttt{develop} branch:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
git clone https://github.com/sunoc/Micro-XRCE-DDS-Agent.git -b develop
cd Micro-XRCE-DDS-Agent
mkdir build
cd build
cmake ..
make
\end{minted}

Giving that your are working from an environment in which the ROS2 tools are available, it is then possible
to run the Agent as follow\footnote{The \texttt{-{}-{}dev /dev/null} option is only a placeholder as the serial requires it but not RPMsg.} \textsuperscript{,}\,\footnote{The \texttt{-{}-{}verbose 6} allows to see the maximum amount of information about the data being transmitted.}:

\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
source /opt/ros/$ROS_DISTRO/setup.bash

./MicroXRCEAgent serial --dev /dev/null --verbose 6
\end{minted}


\clearpage
\section{micro-ROS Talker}
\label{sec:orga359ed7}

\clearpage
\section{Running the ping-pong node\hfill{}\textsc{WORK\_IN\_PROGRESS}}
\label{sec:orgcbe8b7f}
A custom ping-pong node for ROS2 was developed in order to test the data transfer of the newly created
Agent / Client system.

In order to have this node up and running, you need to set basically all the previously presented points:
\begin{itemize}
\item The micro-ROS firmware is running on the R5F core, as presented in the section \ref{sec:org7608166}.
\item On the same Linux you plan to run the node, you will need to run and keep the Agent, as presented
in the section \ref{sec:org11c0cec}.
\item This ping-pong application is released as a ROS2 Python node. It is best to pull and run it
in a ROS2 environment to avoid having dependencies issues, as presented in the section about ROS2.

\clearpage
\end{itemize}
\section{Monitoring and performances evaluation\hfill{}\textsc{WORK\_IN\_PROGRESS}}
\label{sec:org494e44f}

\clearpage
\section{Conclusion \& future\hfill{}\textsc{WORK\_IN\_PROGRESS}}
\label{sec:org127e2e5}

\clearpage
\appendix
\section{DTO patch}
\label{sec:org731fdfb}
This file is available in this repository: \href{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/system.patch}{system.patch}
\inputminted[linenos, frame=single]{diff}{./src/system.patch}

\clearpage
\section{Custom tool-chain CMake settings}
\label{sec:orgc028b26}
This file is available in this repository: \href{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom\_r5f\_toolchain.cmake}{custom r5f toolchain.cmake}
\inputminted[linenos, frame=single]{cmake}{./src/custom_r5f_toolchain.cmake}

\clearpage
\section{Custom Colcon meta settings}
\label{sec:org8110b30}
This file is available in this repository: \href{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/custom\_r5f\_colcon.meta}{custom r5f colcon.meta}
\inputminted[linenos, frame=single]{yaml}{./src/custom_r5f_colcon.meta}

\clearpage
\section{Firmware time functions}
\label{sec:orge8646b1}

\subsection{main}
\label{sec:org830ed90}
This file is available in this repository: \href{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/clock.c}{clock.c}
but a potentially more up-to-date version is visible
directly at the \texttt{libmicroros\_kv260} repository: \href{https://gitlab.com/sunoc/libmicroros\_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/clock.c}{clock.c}

\inputminted[linenos, frame=single]{c}{./src/clock.c}

\subsection{header file}
\label{sec:org04636d0}
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{c}
/**< Microseconds per second. */
#define MICROSECONDS_PER_SECOND    ( 1000000LL )  
/**< Nanoseconds per second. */
#define NANOSECONDS_PER_SECOND     ( 1000000000LL ) 
/**< Nanoseconds per FreeRTOS tick. */  
#define NANOSECONDS_PER_TICK       ( NANOSECONDS_PER_SECOND / configTICK_RATE_HZ ) 
\end{minted}


\clearpage
\section{Firmware memory allocation functions}
\label{sec:org9284958}

\subsection{main}
\label{sec:org5d2ddfe}
This file is available in this repository: \href{https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/blob/b7300116e153f4b5a1542f8804e4646db8030033/src/allocators.c}{allocators.c}
but a potentially more up-to-date version is visible
directly at the \texttt{libmicroros\_kv260} repository: \href{https://gitlab.com/sunoc/libmicroros\_kv260/-/blob/4867e762f66af7b4647232eb4c0a31106db66e13/src/allocators.c}{allocators.c}

\inputminted[linenos, frame=single]{c}{./src/allocators.c}

\subsection{header file}
\label{sec:orgc0bdd1f}
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{c}
#ifndef _ALLOCATORS_H_
#define _ALLOCATORS_H_

#include "microros.h"

extern int absoluteUsedMemory;
extern int usedMemory;


void * __freertos_allocate(size_t size, void * state);
void __freertos_deallocate(void * pointer, void * state);
void * __freertos_reallocate(void * pointer, size_t size, void * state);
void * __freertos_zero_allocate(size_t number_of_elements,
                                size_t size_of_element, void * state);

#endif // _ALLOCATORS_H_
\end{minted}
\section{[deprecated] Installing Linux (PetaLinux option)}
\label{sec:org8f8b750}
This part is an alternative to the previous section \ref{sec:org4edd679},
where the installation of PetaLinux as a host system\footnote{It is to be noted that for this part, the "other" KRIA board (KR260) was
used instead of the KV260 that was being used for everything tried on top of
Ubuntu. No significant difference should be noted.} will be presented,
as being an alternative to the Ubuntu LTS. Here are some reasoning why you'd
prefer to use PetaLinux instead of Ubuntu:
\begin{itemize}
\item Direct support from Xilinx. While Ubuntu is also an official port, it is
provided through Canonical.
\item If you plan to use ROS2 in containers.
\end{itemize}

It is also to be noted that the building process of a PetaLinux image is not as
trivial as simply flashing a downloaded ISO file. It takes some time to
configure it and even more time to be built, especially if you are working on a
lower-end machine.

\subsection{General installation}
\label{sec:orgfe62c8a}
The indication on how to install PetaLinux on a KRIA board is detailed in the
official documentation\footnote{\url{https://xilinx.github.io/kria-apps-docs/kv260/2021.1/build/html/docs/build\_petalinux.html}}, but for the KV260 board with an older release of
the Linux. This guide will try to keep an up-to-date version of the guide, in
particular for the KR260 KRIA board and, at the time of writing, the PetaLinux
in version 2023.2 for the installer.  The 2022.2 version is recommended for this
board's latest updated boot firmware, as presented in the Section Boot firmware
above; however I happened to have issues with the building process from a system
based on Ubuntu 22.04. Thus the choice of the 2023.2 that should be compatible.

Two tools should be downloaded upfront in order to be ready and create the
PetaLinux image for our target board. Both can be obtained at the Xilinx
official download page\footnote{\url{https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2022-2.html}}. Login with an AMD account is required in order to
download the files we need, namely, we'll have to get:
\begin{itemize}
\item The installer tool: \texttt{petalinux-v2023.2-10121855-installer.run} or similar name.
\item The SOM board support package: \texttt{xilinx-kr260-starterkit-v2023.2-10140544.bsp} or similar name\footnote{As of the time of writing this section, it was recommended\footnotemark to be
using the boot firmware in version 2022.2. Thus the software pack for the board
will also be using this version.}\footnotetext[39]{\label{org68ef981}\url{https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/1641152513/Kria+SOMs+Starter+Kits\#K26-Boot-Firmware-Updates}}.
\end{itemize}
The specific name of the utils you'll get to download will evolve over time.

For the following command, I will assume that both files were downloaded into
the same directory and that you have a shell open in said directory.

Firstly, a crap ton of dependencies are needed. They are detailed in the
release notes of the version of the tool you are downloading and it depends on
your distribution, but here is a one-liner that works for the PetaLinux 2023.2
to be built on Ubuntu(-based) 22.04 LTS:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get install iproute2 gawk python3 build-essential gcc git make \
     net-tools libncurses5-dev tftpd zlib1g-dev libssl-dev flex bison libselinux1 \
     gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip \
     texinfo zlib1g-dev gcc-multilib automake zlib1g:i386 screen pax gzip cpio \
     python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git \
     python3-jinja2 libegl1-mesa libsdl1.2-dev pylint asciidoc
\end{minted}

Testing, if building on Debian 12 the following variant of the same command has been confirmed to work:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo apt-get install iproute2 gawk python3 build-essential gcc git make \
net-tools libncurses5-dev tftpd-hpa zlib1g-dev libssl-dev flex bison libselinux1 \
gnupg wget git-core diffstat chrpath socat xterm autoconf libtool tar unzip \
texinfo zlib1g-dev gcc-multilib automake zlib1g screen pax gzip cpio python3-pip \
python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 \
libegl1-mesa libsdl1.2-dev pylint asciidoc
\end{minted}

Installing the petalinux tools can be done with the \texttt{.run} script\footnote{It is to be noted that the \texttt{source} command will run best on \texttt{bash}. Trying
to run it on \texttt{zsh} for ex. will cause issues. This can be enforced with the
command \texttt{sudo dpkg-reconfigure bash}.}, as follow:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo chmod +x ./petalinux-v2023.2-10121855-installer.run
./petalinux-v2023.2-10121855-installer.run
bash
source settings.sh
\end{minted}

A project can then be created, using the \texttt{.bsp} file. From there it is possible to
build the image file meant to be booted by the board:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
petalinux-create -t project -s xilinx-kr260-starterkit-v2023.2-10140544.bsp
cd xilinx-kr260-starterkit-2023.2/
\end{minted}


The more general option allows to enable stuff related to hardware
configuration\footnote{If you search in the work directory, you might notice that three
differently named \texttt{.xsa} files exist. After a quick \texttt{diff} check, they appear to be
exactly identical.}. For this step, it is possible to select the \texttt{openAMP}
setting the the DTG Settings, as visible in the Figure \ref{fig:orga07c477} below:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
petalinux-config --get-hw-description  ./hardware/xilinx-kr260-starterkit-2023.2/kr260_starter_kit.xsa
\end{minted}

Then, here are the options that we want to enable:
\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/yocto_openamp_dtg.png}
\caption{\label{fig:orga07c477}In the hardware config, it is possible to select the openamp device tree source.}
\end{figure}

Some kernel and module configuration are needed in order for the petalinux system to work properly.
These setup can be set using the following command:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
petalinux-config -c rootfs
\end{minted}

Then, here are the options that we want to enable:
\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/yocto_openamp.png}
\caption{\label{fig:orgbf78932}In the rootfs config, it is possible to select the openamp package.}
\end{figure}


\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/yocto_ssh.png}
\caption{\label{fig:org8a1a719}OpenSSH can be configure in the same rootfs config.}
\end{figure}

It is then possible to build\footnote{Beware, the \texttt{petalinux-build} command execution takes a lot of time.} and package the image. Most critically compared to the example,
the \texttt{openamp.dtb} overlay must be used in order for OpenAMP and subsequently RPMsg to become usable.
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
petalinux-build
petalinux-package --wic --bootfiles "ramdisk.cpio.gz.u-boot boot.scr Image system.dtb"
\end{minted}

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black]
\textbf{DANGER}: The next part involve the \texttt{dd} command writing on disks!!!
As always with the dd command, thou have to be \textbf{VERY} careful on what arguments
thou give. Selecting the wrong disk will result on the destruction of
thy data !!
\uline{If you are unsure of what to do, seek assistance !}
\end{tcolorbox}

Finally, and now an image has been generated, it can be burnt to a micro-SD card the usual way:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo dd if=./images/linux/petalinux-sdimage.wic \
     of=/dev/sda status=progress bs=8M && sync
\end{minted}

From that point, the media can be ejected, put in the board and the boot process
should happen successfully.

\subsection{First login}
\label{sec:orgf9eb853}
On the first start, if you have a serial terminal open to the KR260 board, you'll be prompter to enter a login.
The default user it \texttt{petalinux}. You'll then be prompted to enter a password.

\subsection{Testing openamp "echo-test"}
\label{sec:orgdcf53da}
A good and out-of-the-box way to try and confirm that the OpenAMP setup was done
properly is to run the so-called "echo-test". This program will basically send
series of packages to the R5F core and expect them to be returned.

As presented in the official documentation\footnote{\url{https://xilinx.github.io/kria-apps-docs/openamp/build/html/openamp\_landing.html\#openamp-demos}}, this can be simply done with
the following commands. If the return of the \texttt{echo\_test} commands states that zero
error occurs, the system should be good to go:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo -s
echo image_echo_test  > /sys/class/remoteproc/remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
\end{minted}

\subsection{"echo-test" performance comparison}
\label{sec:org7880af4}

Now we have a working demonstration for RPMsg, a goal was to compare this system between boards.

Here is the complete sequence in order to archive a timely measured \texttt{echo\_test} run, namely:
\begin{itemize}
\item Installation of the build dependencies
\item Clone of the Xilinx repository
\item Patching of the main source to add the time measurement
\item Building of the test software
\item Communication with the R5F, with reload of the firmware
\end{itemize}
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo dnf install git make gcc binutils packagegroup-core-buildessential
sudo ln -s /usr/bin/aarch64-xilinx-linux-gcc /bin/cc
git clone https://github.com/OpenAMP/openamp-system-reference.git
cd openamp-system-reference/examples/linux/rpmsg-echo-test/
wget https://gitlab.com/sunoc/xilinx-kria-kv260-documentation/-/raw/main/src/echo_test.patch
patch -u -b echo_test.c -i echo_test.patch
make
sudo -s
echo image_echo_test  > /sys/class/remoteproc/remoteproc0/firmware
echo start > /sys/class/remoteproc/remoteproc0/state
./echo_test
echo stop > /sys/class/remoteproc/remoteproc0/state
\end{minted}


The figure \ref{fig:orgcc47ac8} below shows a comparison for the data
throughput that is reachable for a packages round trip of individual RPMsg
packages for both PetaLinux running on the KR260 board and Ubuntu running on the
KV260.

A difference exist but it is not as significant as to explain the rather slow
transfer rate when used in combination with ROS2 DDS.

\begin{figure}[htbp]
\centering
\includegraphics[width=.6\textwidth]{./img/kr260_echo_test_density.png}
\caption{\label{fig:orgcc47ac8}A graph of the data transfer rate for individual packages to be transmitted and received back from the Linux.}
\end{figure}

This fast delay for data transmission was later confirmed by measurement done using an external logic analyser\footnote{\url{https://gitlab.com/sunoc/saleae-logic-8-documentation}}.

\subsection{Enabling SSH}
\label{sec:org530e702}
\subsection{Setting up a static IP address for PetaLinux}
\label{sec:orgf703fb6}
This is not a trivial task in petalinux.

As it appears, the classic \texttt{/etc/network/interfaces} must be modified, however and
for some unknown reason the DHCP keep being used even when disabled, and the
actual static interface is not used until restarted.

Multiple steps are required in order to mitigate all of this.

First, we can make our standard \texttt{interfaces} configuration, in the  \texttt{/etc/network/interfaces}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
# Wired or wireless interfaces
auto eth0
iface eth0 inet static
address 192.168.11.107
netmask 255.255.255.0
network 192.168.11.0
gateway 192.168.11.1
\end{minted}

Then we need to have \texttt{systemd} to run a script after boot time to restart the \texttt{eth0} interface.

A very basic script, as follow need to be placed somewhere on the system, for example here, in the \texttt{/home/root/net.sh}:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
#!/bin/sh -e
ifdown eth0
ifup eth0
exit 0
\end{minted}

Then, we want to create a \texttt{systemd} service that will run this script as \texttt{idle},
i.e. after all the rest. Said file, in our case named \texttt{updown.service} must be
placed in the \texttt{/etc/systemd/system/} directory:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{yaml}
[Unit]
Description=Restart once more the eth0 network to enable the static IP

[Service]
Type=idle
ExecStart=/bin/sh /home/root/net.sh

[Install]
WantedBy=multi-user.target
\end{minted}

Finally, as a \texttt{root} we need to set the correct right for these files and finally enabling the service before reboot:
\begin{minted}[frame=single,framesep=2mm,baselinestretch=1.2,linenos,breaklines,fontsize=\footnotesize]{sh}
sudo -s
chmod +x /home/root/net.sh
chmod 644 /etc/systemd/system/updown.service
systemctl enable updown.service
reboot now
\end{minted}

With all of this, on the next reboot of the board, the static IP should be available alongside the DHCP IP.

\section{References}
\label{sec:orgaaf5dad}
\bibliographystyle{ieeetr}
\bibliography{../../Nextcloud/PARA/3_Researches/Bibliography/references}
\end{document}
